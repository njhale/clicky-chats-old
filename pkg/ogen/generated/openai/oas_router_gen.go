// Code generated by ogen, DO NOT EDIT.

package api

import (
	"net/http"
	"net/url"
	"strings"

	"github.com/ogen-go/ogen/uri"
)

func (s *Server) cutPrefix(path string) (string, bool) {
	prefix := s.cfg.Prefix
	if prefix == "" {
		return path, true
	}
	if !strings.HasPrefix(path, prefix) {
		// Prefix doesn't match.
		return "", false
	}
	// Cut prefix from the path.
	return strings.TrimPrefix(path, prefix), true
}

// ServeHTTP serves http request as defined by OpenAPI v3 specification,
// calling handler that matches the path or returning not found error.
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	elem := r.URL.Path
	elemIsEscaped := false
	if rawPath := r.URL.RawPath; rawPath != "" {
		if normalized, ok := uri.NormalizeEscapedPath(rawPath); ok {
			elem = normalized
			elemIsEscaped = strings.ContainsRune(elem, '%')
		}
	}

	elem, ok := s.cutPrefix(elem)
	if !ok || len(elem) == 0 {
		s.notFound(w, r)
		return
	}
	args := [3]string{}

	// Static code generated router with unwrapped path search.
	switch {
	default:
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"
			origElem := elem
			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				break
			}
			switch elem[0] {
			case 'a': // Prefix: "a"
				origElem := elem
				if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 's': // Prefix: "ssistants"
					origElem := elem
					if l := len("ssistants"); len(elem) >= l && elem[0:l] == "ssistants" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleListAssistantsRequest([0]string{}, elemIsEscaped, w, r)
						case "POST":
							s.handleCreateAssistantRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						origElem := elem
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "assistant_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "DELETE":
								s.handleDeleteAssistantRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "GET":
								s.handleGetAssistantRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "POST":
								s.handleModifyAssistantRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET,POST")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/files"
							origElem := elem
							if l := len("/files"); len(elem) >= l && elem[0:l] == "/files" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleListAssistantFilesRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "POST":
									s.handleCreateAssistantFileRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								origElem := elem
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "file_id"
								// Leaf parameter
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleDeleteAssistantFileRequest([2]string{
											args[0],
											args[1],
										}, elemIsEscaped, w, r)
									case "GET":
										s.handleGetAssistantFileRequest([2]string{
											args[0],
											args[1],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET")
									}

									return
								}

								elem = origElem
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				case 'u': // Prefix: "udio/"
					origElem := elem
					if l := len("udio/"); len(elem) >= l && elem[0:l] == "udio/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 's': // Prefix: "speech"
						origElem := elem
						if l := len("speech"); len(elem) >= l && elem[0:l] == "speech" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleCreateSpeechRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

						elem = origElem
					case 't': // Prefix: "trans"
						origElem := elem
						if l := len("trans"); len(elem) >= l && elem[0:l] == "trans" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'c': // Prefix: "criptions"
							origElem := elem
							if l := len("criptions"); len(elem) >= l && elem[0:l] == "criptions" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleCreateTranscriptionRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

							elem = origElem
						case 'l': // Prefix: "lations"
							origElem := elem
							if l := len("lations"); len(elem) >= l && elem[0:l] == "lations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleCreateTranslationRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				}

				elem = origElem
			case 'c': // Prefix: "chat/completions"
				origElem := elem
				if l := len("chat/completions"); len(elem) >= l && elem[0:l] == "chat/completions" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					// Leaf node.
					switch r.Method {
					case "POST":
						s.handleCreateChatCompletionRequest([0]string{}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "POST")
					}

					return
				}

				elem = origElem
			case 'f': // Prefix: "fi"
				origElem := elem
				if l := len("fi"); len(elem) >= l && elem[0:l] == "fi" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'l': // Prefix: "les"
					origElem := elem
					if l := len("les"); len(elem) >= l && elem[0:l] == "les" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleListFilesRequest([0]string{}, elemIsEscaped, w, r)
						case "POST":
							s.handleCreateFileRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						origElem := elem
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "file_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "DELETE":
								s.handleDeleteFileRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "GET":
								s.handleRetrieveFileRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/content"
							origElem := elem
							if l := len("/content"); len(elem) >= l && elem[0:l] == "/content" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleDownloadFileRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				case 'n': // Prefix: "ne_tuning/jobs"
					origElem := elem
					if l := len("ne_tuning/jobs"); len(elem) >= l && elem[0:l] == "ne_tuning/jobs" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleListPaginatedFineTuningJobsRequest([0]string{}, elemIsEscaped, w, r)
						case "POST":
							s.handleCreateFineTuningJobRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						origElem := elem
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "fine_tuning_job_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleRetrieveFineTuningJobRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							origElem := elem
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "cancel"
								origElem := elem
								if l := len("cancel"); len(elem) >= l && elem[0:l] == "cancel" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleCancelFineTuningJobRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

								elem = origElem
							case 'e': // Prefix: "events"
								origElem := elem
								if l := len("events"); len(elem) >= l && elem[0:l] == "events" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleListFineTuningEventsRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

								elem = origElem
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				}

				elem = origElem
			case 'i': // Prefix: "images/"
				origElem := elem
				if l := len("images/"); len(elem) >= l && elem[0:l] == "images/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'e': // Prefix: "edits"
					origElem := elem
					if l := len("edits"); len(elem) >= l && elem[0:l] == "edits" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "POST":
							s.handleCreateImageEditRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "POST")
						}

						return
					}

					elem = origElem
				case 'g': // Prefix: "generations"
					origElem := elem
					if l := len("generations"); len(elem) >= l && elem[0:l] == "generations" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "POST":
							s.handleCreateImageRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "POST")
						}

						return
					}

					elem = origElem
				case 'v': // Prefix: "variations"
					origElem := elem
					if l := len("variations"); len(elem) >= l && elem[0:l] == "variations" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "POST":
							s.handleCreateImageVariationRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "POST")
						}

						return
					}

					elem = origElem
				}

				elem = origElem
			case 'm': // Prefix: "mode"
				origElem := elem
				if l := len("mode"); len(elem) >= l && elem[0:l] == "mode" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'l': // Prefix: "ls"
					origElem := elem
					if l := len("ls"); len(elem) >= l && elem[0:l] == "ls" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleListModelsRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						origElem := elem
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "model"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "DELETE":
								s.handleDeleteModelRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "GET":
								s.handleRetrieveModelRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET")
							}

							return
						}

						elem = origElem
					}

					elem = origElem
				case 'r': // Prefix: "rations"
					origElem := elem
					if l := len("rations"); len(elem) >= l && elem[0:l] == "rations" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "POST":
							s.handleCreateModerationRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "POST")
						}

						return
					}

					elem = origElem
				}

				elem = origElem
			case 't': // Prefix: "threads"
				origElem := elem
				if l := len("threads"); len(elem) >= l && elem[0:l] == "threads" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch r.Method {
					case "POST":
						s.handleCreateThreadRequest([0]string{}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "POST")
					}

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					origElem := elem
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'r': // Prefix: "runs"
						origElem := elem
						if l := len("runs"); len(elem) >= l && elem[0:l] == "runs" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleCreateThreadAndRunRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

						elem = origElem
					}
					// Param: "thread_id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						switch r.Method {
						case "DELETE":
							s.handleDeleteThreadRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						case "GET":
							s.handleGetThreadRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						case "POST":
							s.handleModifyThreadRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "DELETE,GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						origElem := elem
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'm': // Prefix: "messages"
							origElem := elem
							if l := len("messages"); len(elem) >= l && elem[0:l] == "messages" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleListMessagesRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "POST":
									s.handleCreateMessageRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								origElem := elem
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "message_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[1] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleGetMessageRequest([2]string{
											args[0],
											args[1],
										}, elemIsEscaped, w, r)
									case "POST":
										s.handleModifyMessageRequest([2]string{
											args[0],
											args[1],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET,POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/files"
									origElem := elem
									if l := len("/files"); len(elem) >= l && elem[0:l] == "/files" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleListMessageFilesRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										origElem := elem
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "file_id"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleGetMessageFileRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

										elem = origElem
									}

									elem = origElem
								}

								elem = origElem
							}

							elem = origElem
						case 'r': // Prefix: "runs"
							origElem := elem
							if l := len("runs"); len(elem) >= l && elem[0:l] == "runs" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleListRunsRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "POST":
									s.handleCreateRunRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								origElem := elem
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "run_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[1] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleGetRunRequest([2]string{
											args[0],
											args[1],
										}, elemIsEscaped, w, r)
									case "POST":
										s.handleModifyRunRequest([2]string{
											args[0],
											args[1],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET,POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									origElem := elem
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'c': // Prefix: "cancel"
										origElem := elem
										if l := len("cancel"); len(elem) >= l && elem[0:l] == "cancel" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handleCancelRunRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}

										elem = origElem
									case 's': // Prefix: "s"
										origElem := elem
										if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 't': // Prefix: "teps"
											origElem := elem
											if l := len("teps"); len(elem) >= l && elem[0:l] == "teps" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleListRunStepsRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												origElem := elem
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "step_id"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleGetRunStepRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}

												elem = origElem
											}

											elem = origElem
										case 'u': // Prefix: "ubmit_tool_outputs"
											origElem := elem
											if l := len("ubmit_tool_outputs"); len(elem) >= l && elem[0:l] == "ubmit_tool_outputs" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handleSubmitToolOuputsToRunRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}

											elem = origElem
										}

										elem = origElem
									}

									elem = origElem
								}

								elem = origElem
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				}

				elem = origElem
			}

			elem = origElem
		}
	}
	s.notFound(w, r)
}

// Route is route object.
type Route struct {
	name        string
	summary     string
	operationID string
	pathPattern string
	count       int
	args        [3]string
}

// Name returns ogen operation name.
//
// It is guaranteed to be unique and not empty.
func (r Route) Name() string {
	return r.name
}

// Summary returns OpenAPI summary.
func (r Route) Summary() string {
	return r.summary
}

// OperationID returns OpenAPI operationId.
func (r Route) OperationID() string {
	return r.operationID
}

// PathPattern returns OpenAPI path.
func (r Route) PathPattern() string {
	return r.pathPattern
}

// Args returns parsed arguments.
func (r Route) Args() []string {
	return r.args[:r.count]
}

// FindRoute finds Route for given method and path.
//
// Note: this method does not unescape path or handle reserved characters in path properly. Use FindPath instead.
func (s *Server) FindRoute(method, path string) (Route, bool) {
	return s.FindPath(method, &url.URL{Path: path})
}

// FindPath finds Route for given method and URL.
func (s *Server) FindPath(method string, u *url.URL) (r Route, _ bool) {
	var (
		elem = u.Path
		args = r.args
	)
	if rawPath := u.RawPath; rawPath != "" {
		if normalized, ok := uri.NormalizeEscapedPath(rawPath); ok {
			elem = normalized
		}
		defer func() {
			for i, arg := range r.args[:r.count] {
				if unescaped, err := url.PathUnescape(arg); err == nil {
					r.args[i] = unescaped
				}
			}
		}()
	}

	elem, ok := s.cutPrefix(elem)
	if !ok {
		return r, false
	}

	// Static code generated router with unwrapped path search.
	switch {
	default:
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"
			origElem := elem
			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				break
			}
			switch elem[0] {
			case 'a': // Prefix: "a"
				origElem := elem
				if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 's': // Prefix: "ssistants"
					origElem := elem
					if l := len("ssistants"); len(elem) >= l && elem[0:l] == "ssistants" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "ListAssistants"
							r.summary = "Returns a list of assistants."
							r.operationID = "listAssistants"
							r.pathPattern = "/assistants"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = "CreateAssistant"
							r.summary = "Create an assistant with a model and instructions."
							r.operationID = "createAssistant"
							r.pathPattern = "/assistants"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						origElem := elem
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "assistant_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								r.name = "DeleteAssistant"
								r.summary = "Delete an assistant."
								r.operationID = "deleteAssistant"
								r.pathPattern = "/assistants/{assistant_id}"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								r.name = "GetAssistant"
								r.summary = "Retrieves an assistant."
								r.operationID = "getAssistant"
								r.pathPattern = "/assistants/{assistant_id}"
								r.args = args
								r.count = 1
								return r, true
							case "POST":
								r.name = "ModifyAssistant"
								r.summary = "Modifies an assistant."
								r.operationID = "modifyAssistant"
								r.pathPattern = "/assistants/{assistant_id}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/files"
							origElem := elem
							if l := len("/files"); len(elem) >= l && elem[0:l] == "/files" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = "ListAssistantFiles"
									r.summary = "Returns a list of assistant files."
									r.operationID = "listAssistantFiles"
									r.pathPattern = "/assistants/{assistant_id}/files"
									r.args = args
									r.count = 1
									return r, true
								case "POST":
									r.name = "CreateAssistantFile"
									r.summary = "Create an assistant file by attaching a [File](/docs/api-reference/files) to an [assistant](/docs/api-reference/assistants)."
									r.operationID = "createAssistantFile"
									r.pathPattern = "/assistants/{assistant_id}/files"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								origElem := elem
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "file_id"
								// Leaf parameter
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										// Leaf: DeleteAssistantFile
										r.name = "DeleteAssistantFile"
										r.summary = "Delete an assistant file."
										r.operationID = "deleteAssistantFile"
										r.pathPattern = "/assistants/{assistant_id}/files/{file_id}"
										r.args = args
										r.count = 2
										return r, true
									case "GET":
										// Leaf: GetAssistantFile
										r.name = "GetAssistantFile"
										r.summary = "Retrieves an AssistantFile."
										r.operationID = "getAssistantFile"
										r.pathPattern = "/assistants/{assistant_id}/files/{file_id}"
										r.args = args
										r.count = 2
										return r, true
									default:
										return
									}
								}

								elem = origElem
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				case 'u': // Prefix: "udio/"
					origElem := elem
					if l := len("udio/"); len(elem) >= l && elem[0:l] == "udio/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 's': // Prefix: "speech"
						origElem := elem
						if l := len("speech"); len(elem) >= l && elem[0:l] == "speech" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "POST":
								// Leaf: CreateSpeech
								r.name = "CreateSpeech"
								r.summary = "Generates audio from the input text."
								r.operationID = "createSpeech"
								r.pathPattern = "/audio/speech"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

						elem = origElem
					case 't': // Prefix: "trans"
						origElem := elem
						if l := len("trans"); len(elem) >= l && elem[0:l] == "trans" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'c': // Prefix: "criptions"
							origElem := elem
							if l := len("criptions"); len(elem) >= l && elem[0:l] == "criptions" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "POST":
									// Leaf: CreateTranscription
									r.name = "CreateTranscription"
									r.summary = "Transcribes audio into the input language."
									r.operationID = "createTranscription"
									r.pathPattern = "/audio/transcriptions"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

							elem = origElem
						case 'l': // Prefix: "lations"
							origElem := elem
							if l := len("lations"); len(elem) >= l && elem[0:l] == "lations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "POST":
									// Leaf: CreateTranslation
									r.name = "CreateTranslation"
									r.summary = "Translates audio into English."
									r.operationID = "createTranslation"
									r.pathPattern = "/audio/translations"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				}

				elem = origElem
			case 'c': // Prefix: "chat/completions"
				origElem := elem
				if l := len("chat/completions"); len(elem) >= l && elem[0:l] == "chat/completions" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch method {
					case "POST":
						// Leaf: CreateChatCompletion
						r.name = "CreateChatCompletion"
						r.summary = "Creates a model response for the given chat conversation."
						r.operationID = "createChatCompletion"
						r.pathPattern = "/chat/completions"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}

				elem = origElem
			case 'f': // Prefix: "fi"
				origElem := elem
				if l := len("fi"); len(elem) >= l && elem[0:l] == "fi" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'l': // Prefix: "les"
					origElem := elem
					if l := len("les"); len(elem) >= l && elem[0:l] == "les" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "ListFiles"
							r.summary = "Returns a list of files that belong to the user's organization."
							r.operationID = "listFiles"
							r.pathPattern = "/files"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = "CreateFile"
							r.summary = "Upload a file that can be used across various endpoints. The size of all the files uploaded by one organization can be up to 100 GB.\n\nThe size of individual files can be a maximum of 512 MB or 2 million tokens for Assistants. See the [Assistants Tools guide](/docs/assistants/tools) to learn more about the types of files supported. The Fine-tuning API only supports `.jsonl` files.\n\nPlease [contact us](https://help.openai.com/) if you need to increase these storage limits.\n"
							r.operationID = "createFile"
							r.pathPattern = "/files"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						origElem := elem
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "file_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								r.name = "DeleteFile"
								r.summary = "Delete a file."
								r.operationID = "deleteFile"
								r.pathPattern = "/files/{file_id}"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								r.name = "RetrieveFile"
								r.summary = "Returns information about a specific file."
								r.operationID = "retrieveFile"
								r.pathPattern = "/files/{file_id}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/content"
							origElem := elem
							if l := len("/content"); len(elem) >= l && elem[0:l] == "/content" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: DownloadFile
									r.name = "DownloadFile"
									r.summary = "Returns the contents of the specified file."
									r.operationID = "downloadFile"
									r.pathPattern = "/files/{file_id}/content"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				case 'n': // Prefix: "ne_tuning/jobs"
					origElem := elem
					if l := len("ne_tuning/jobs"); len(elem) >= l && elem[0:l] == "ne_tuning/jobs" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "ListPaginatedFineTuningJobs"
							r.summary = "List your organization's fine-tuning jobs\n"
							r.operationID = "listPaginatedFineTuningJobs"
							r.pathPattern = "/fine_tuning/jobs"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = "CreateFineTuningJob"
							r.summary = "Creates a fine-tuning job which begins the process of creating a new model from a given dataset.\n\nResponse includes details of the enqueued job including job status and the name of the fine-tuned models once complete.\n\n[Learn more about fine-tuning](/docs/guides/fine-tuning)\n"
							r.operationID = "createFineTuningJob"
							r.pathPattern = "/fine_tuning/jobs"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						origElem := elem
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "fine_tuning_job_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = "RetrieveFineTuningJob"
								r.summary = "Get info about a fine-tuning job.\n\n[Learn more about fine-tuning](/docs/guides/fine-tuning)\n"
								r.operationID = "retrieveFineTuningJob"
								r.pathPattern = "/fine_tuning/jobs/{fine_tuning_job_id}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							origElem := elem
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "cancel"
								origElem := elem
								if l := len("cancel"); len(elem) >= l && elem[0:l] == "cancel" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "POST":
										// Leaf: CancelFineTuningJob
										r.name = "CancelFineTuningJob"
										r.summary = "Immediately cancel a fine-tune job.\n"
										r.operationID = "cancelFineTuningJob"
										r.pathPattern = "/fine_tuning/jobs/{fine_tuning_job_id}/cancel"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

								elem = origElem
							case 'e': // Prefix: "events"
								origElem := elem
								if l := len("events"); len(elem) >= l && elem[0:l] == "events" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: ListFineTuningEvents
										r.name = "ListFineTuningEvents"
										r.summary = "Get status updates for a fine-tuning job.\n"
										r.operationID = "listFineTuningEvents"
										r.pathPattern = "/fine_tuning/jobs/{fine_tuning_job_id}/events"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

								elem = origElem
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				}

				elem = origElem
			case 'i': // Prefix: "images/"
				origElem := elem
				if l := len("images/"); len(elem) >= l && elem[0:l] == "images/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'e': // Prefix: "edits"
					origElem := elem
					if l := len("edits"); len(elem) >= l && elem[0:l] == "edits" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "POST":
							// Leaf: CreateImageEdit
							r.name = "CreateImageEdit"
							r.summary = "Creates an edited or extended image given an original image and a prompt."
							r.operationID = "createImageEdit"
							r.pathPattern = "/images/edits"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

					elem = origElem
				case 'g': // Prefix: "generations"
					origElem := elem
					if l := len("generations"); len(elem) >= l && elem[0:l] == "generations" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "POST":
							// Leaf: CreateImage
							r.name = "CreateImage"
							r.summary = "Creates an image given a prompt."
							r.operationID = "createImage"
							r.pathPattern = "/images/generations"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

					elem = origElem
				case 'v': // Prefix: "variations"
					origElem := elem
					if l := len("variations"); len(elem) >= l && elem[0:l] == "variations" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "POST":
							// Leaf: CreateImageVariation
							r.name = "CreateImageVariation"
							r.summary = "Creates a variation of a given image."
							r.operationID = "createImageVariation"
							r.pathPattern = "/images/variations"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

					elem = origElem
				}

				elem = origElem
			case 'm': // Prefix: "mode"
				origElem := elem
				if l := len("mode"); len(elem) >= l && elem[0:l] == "mode" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'l': // Prefix: "ls"
					origElem := elem
					if l := len("ls"); len(elem) >= l && elem[0:l] == "ls" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "ListModels"
							r.summary = "Lists the currently available models, and provides basic information about each one such as the owner and availability."
							r.operationID = "listModels"
							r.pathPattern = "/models"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						origElem := elem
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "model"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								// Leaf: DeleteModel
								r.name = "DeleteModel"
								r.summary = "Delete a fine-tuned model. You must have the Owner role in your organization to delete a model."
								r.operationID = "deleteModel"
								r.pathPattern = "/models/{model}"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								// Leaf: RetrieveModel
								r.name = "RetrieveModel"
								r.summary = "Retrieves a model instance, providing basic information about the model such as the owner and permissioning."
								r.operationID = "retrieveModel"
								r.pathPattern = "/models/{model}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}

						elem = origElem
					}

					elem = origElem
				case 'r': // Prefix: "rations"
					origElem := elem
					if l := len("rations"); len(elem) >= l && elem[0:l] == "rations" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "POST":
							// Leaf: CreateModeration
							r.name = "CreateModeration"
							r.summary = "Classifies if text is potentially harmful."
							r.operationID = "createModeration"
							r.pathPattern = "/moderations"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

					elem = origElem
				}

				elem = origElem
			case 't': // Prefix: "threads"
				origElem := elem
				if l := len("threads"); len(elem) >= l && elem[0:l] == "threads" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch method {
					case "POST":
						r.name = "CreateThread"
						r.summary = "Create a thread."
						r.operationID = "createThread"
						r.pathPattern = "/threads"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					origElem := elem
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'r': // Prefix: "runs"
						origElem := elem
						if l := len("runs"); len(elem) >= l && elem[0:l] == "runs" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "POST":
								// Leaf: CreateThreadAndRun
								r.name = "CreateThreadAndRun"
								r.summary = "Create a thread and run it in one request."
								r.operationID = "createThreadAndRun"
								r.pathPattern = "/threads/runs"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

						elem = origElem
					}
					// Param: "thread_id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						switch method {
						case "DELETE":
							r.name = "DeleteThread"
							r.summary = "Delete a thread."
							r.operationID = "deleteThread"
							r.pathPattern = "/threads/{thread_id}"
							r.args = args
							r.count = 1
							return r, true
						case "GET":
							r.name = "GetThread"
							r.summary = "Retrieves a thread."
							r.operationID = "getThread"
							r.pathPattern = "/threads/{thread_id}"
							r.args = args
							r.count = 1
							return r, true
						case "POST":
							r.name = "ModifyThread"
							r.summary = "Modifies a thread."
							r.operationID = "modifyThread"
							r.pathPattern = "/threads/{thread_id}"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						origElem := elem
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'm': // Prefix: "messages"
							origElem := elem
							if l := len("messages"); len(elem) >= l && elem[0:l] == "messages" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = "ListMessages"
									r.summary = "Returns a list of messages for a given thread."
									r.operationID = "listMessages"
									r.pathPattern = "/threads/{thread_id}/messages"
									r.args = args
									r.count = 1
									return r, true
								case "POST":
									r.name = "CreateMessage"
									r.summary = "Create a message."
									r.operationID = "createMessage"
									r.pathPattern = "/threads/{thread_id}/messages"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								origElem := elem
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "message_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[1] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = "GetMessage"
										r.summary = "Retrieve a message."
										r.operationID = "getMessage"
										r.pathPattern = "/threads/{thread_id}/messages/{message_id}"
										r.args = args
										r.count = 2
										return r, true
									case "POST":
										r.name = "ModifyMessage"
										r.summary = "Modifies a message."
										r.operationID = "modifyMessage"
										r.pathPattern = "/threads/{thread_id}/messages/{message_id}"
										r.args = args
										r.count = 2
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/files"
									origElem := elem
									if l := len("/files"); len(elem) >= l && elem[0:l] == "/files" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = "ListMessageFiles"
											r.summary = "Returns a list of message files."
											r.operationID = "listMessageFiles"
											r.pathPattern = "/threads/{thread_id}/messages/{message_id}/files"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										origElem := elem
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "file_id"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											switch method {
											case "GET":
												// Leaf: GetMessageFile
												r.name = "GetMessageFile"
												r.summary = "Retrieves a message file."
												r.operationID = "getMessageFile"
												r.pathPattern = "/threads/{thread_id}/messages/{message_id}/files/{file_id}"
												r.args = args
												r.count = 3
												return r, true
											default:
												return
											}
										}

										elem = origElem
									}

									elem = origElem
								}

								elem = origElem
							}

							elem = origElem
						case 'r': // Prefix: "runs"
							origElem := elem
							if l := len("runs"); len(elem) >= l && elem[0:l] == "runs" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = "ListRuns"
									r.summary = "Returns a list of runs belonging to a thread."
									r.operationID = "listRuns"
									r.pathPattern = "/threads/{thread_id}/runs"
									r.args = args
									r.count = 1
									return r, true
								case "POST":
									r.name = "CreateRun"
									r.summary = "Create a run."
									r.operationID = "createRun"
									r.pathPattern = "/threads/{thread_id}/runs"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								origElem := elem
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "run_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[1] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = "GetRun"
										r.summary = "Retrieves a run."
										r.operationID = "getRun"
										r.pathPattern = "/threads/{thread_id}/runs/{run_id}"
										r.args = args
										r.count = 2
										return r, true
									case "POST":
										r.name = "ModifyRun"
										r.summary = "Modifies a run."
										r.operationID = "modifyRun"
										r.pathPattern = "/threads/{thread_id}/runs/{run_id}"
										r.args = args
										r.count = 2
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									origElem := elem
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'c': // Prefix: "cancel"
										origElem := elem
										if l := len("cancel"); len(elem) >= l && elem[0:l] == "cancel" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "POST":
												// Leaf: CancelRun
												r.name = "CancelRun"
												r.summary = "Cancels a run that is `in_progress`."
												r.operationID = "cancelRun"
												r.pathPattern = "/threads/{thread_id}/runs/{run_id}/cancel"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}

										elem = origElem
									case 's': // Prefix: "s"
										origElem := elem
										if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 't': // Prefix: "teps"
											origElem := elem
											if l := len("teps"); len(elem) >= l && elem[0:l] == "teps" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = "ListRunSteps"
													r.summary = "Returns a list of run steps belonging to a run."
													r.operationID = "listRunSteps"
													r.pathPattern = "/threads/{thread_id}/runs/{run_id}/steps"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												origElem := elem
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "step_id"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													switch method {
													case "GET":
														// Leaf: GetRunStep
														r.name = "GetRunStep"
														r.summary = "Retrieves a run step."
														r.operationID = "getRunStep"
														r.pathPattern = "/threads/{thread_id}/runs/{run_id}/steps/{step_id}"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}

												elem = origElem
											}

											elem = origElem
										case 'u': // Prefix: "ubmit_tool_outputs"
											origElem := elem
											if l := len("ubmit_tool_outputs"); len(elem) >= l && elem[0:l] == "ubmit_tool_outputs" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "POST":
													// Leaf: SubmitToolOuputsToRun
													r.name = "SubmitToolOuputsToRun"
													r.summary = "When a run has the `status: \"requires_action\"` and `required_action.type` is `submit_tool_outputs`, this endpoint can be used to submit the outputs from the tool calls once they're all completed. All outputs must be submitted in a single request.\n"
													r.operationID = "submitToolOuputsToRun"
													r.pathPattern = "/threads/{thread_id}/runs/{run_id}/submit_tool_outputs"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}

											elem = origElem
										}

										elem = origElem
									}

									elem = origElem
								}

								elem = origElem
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				}

				elem = origElem
			}

			elem = origElem
		}
	}
	return r, false
}
