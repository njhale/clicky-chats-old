// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AssistantFileObject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssistantFileObject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("object")
		s.Object.Encode(e)
	}
	{
		e.FieldStart("created_at")
		e.Int(s.CreatedAt)
	}
	{
		e.FieldStart("assistant_id")
		e.Str(s.AssistantID)
	}
}

var jsonFieldsNameOfAssistantFileObject = [4]string{
	0: "id",
	1: "object",
	2: "created_at",
	3: "assistant_id",
}

// Decode decodes AssistantFileObject from json.
func (s *AssistantFileObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssistantFileObject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "object":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CreatedAt = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "assistant_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.AssistantID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assistant_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssistantFileObject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAssistantFileObject) {
					name = jsonFieldsNameOfAssistantFileObject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssistantFileObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssistantFileObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AssistantFileObjectObject as json.
func (s AssistantFileObjectObject) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AssistantFileObjectObject from json.
func (s *AssistantFileObjectObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssistantFileObjectObject to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AssistantFileObjectObject(v) {
	case AssistantFileObjectObjectAssistantFile:
		*s = AssistantFileObjectObjectAssistantFile
	default:
		*s = AssistantFileObjectObject(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AssistantFileObjectObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssistantFileObjectObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssistantObject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssistantObject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("object")
		s.Object.Encode(e)
	}
	{
		e.FieldStart("created_at")
		e.Int(s.CreatedAt)
	}
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("model")
		e.Str(s.Model)
	}
	{
		e.FieldStart("instructions")
		s.Instructions.Encode(e)
	}
	{
		e.FieldStart("tools")
		e.ArrStart()
		for _, elem := range s.Tools {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("file_ids")
		e.ArrStart()
		for _, elem := range s.FileIds {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("metadata")
		if s.Metadata == nil {
			e.Null()
		} else {
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfAssistantObject = [10]string{
	0: "id",
	1: "object",
	2: "created_at",
	3: "name",
	4: "description",
	5: "model",
	6: "instructions",
	7: "tools",
	8: "file_ids",
	9: "metadata",
}

// Decode decodes AssistantObject from json.
func (s *AssistantObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssistantObject to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "object":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CreatedAt = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "model":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Model = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		case "instructions":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Instructions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instructions\"")
			}
		case "tools":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.Tools = make([]AssistantObjectToolsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AssistantObjectToolsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tools = append(s.Tools, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tools\"")
			}
		case "file_ids":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				s.FileIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.FileIds = append(s.FileIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_ids\"")
			}
		case "metadata":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				s.Metadata = nil
				var elem AssistantObjectMetadata
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Metadata = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssistantObject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAssistantObject) {
					name = jsonFieldsNameOfAssistantObject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssistantObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssistantObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssistantObjectMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssistantObjectMetadata) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfAssistantObjectMetadata = [0]string{}

// Decode decodes AssistantObjectMetadata from json.
func (s *AssistantObjectMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssistantObjectMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode AssistantObjectMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssistantObjectMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssistantObjectMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AssistantObjectObject as json.
func (s AssistantObjectObject) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AssistantObjectObject from json.
func (s *AssistantObjectObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssistantObjectObject to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AssistantObjectObject(v) {
	case AssistantObjectObjectAssistant:
		*s = AssistantObjectObjectAssistant
	default:
		*s = AssistantObjectObject(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AssistantObjectObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssistantObjectObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AssistantObjectToolsItem as json.
func (s AssistantObjectToolsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s AssistantObjectToolsItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case AssistantToolsCodeAssistantObjectToolsItem:
		e.FieldStart("type")
		e.Str("code_interpreter")
		s.AssistantToolsCode.encodeFields(e)
	case AssistantToolsFunctionAssistantObjectToolsItem:
		e.FieldStart("type")
		e.Str("function")
		s.AssistantToolsFunction.encodeFields(e)
	case AssistantToolsRetrievalAssistantObjectToolsItem:
		e.FieldStart("type")
		e.Str("retrieval")
		s.AssistantToolsRetrieval.encodeFields(e)
	}
}

// Decode decodes AssistantObjectToolsItem from json.
func (s *AssistantObjectToolsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssistantObjectToolsItem to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "code_interpreter":
					s.Type = AssistantToolsCodeAssistantObjectToolsItem
					found = true
				case "function":
					s.Type = AssistantToolsFunctionAssistantObjectToolsItem
					found = true
				case "retrieval":
					s.Type = AssistantToolsRetrievalAssistantObjectToolsItem
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case AssistantToolsCodeAssistantObjectToolsItem:
		if err := s.AssistantToolsCode.Decode(d); err != nil {
			return err
		}
	case AssistantToolsRetrievalAssistantObjectToolsItem:
		if err := s.AssistantToolsRetrieval.Decode(d); err != nil {
			return err
		}
	case AssistantToolsFunctionAssistantObjectToolsItem:
		if err := s.AssistantToolsFunction.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AssistantObjectToolsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssistantObjectToolsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssistantToolsCode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssistantToolsCode) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfAssistantToolsCode = [0]string{}

// Decode decodes AssistantToolsCode from json.
func (s *AssistantToolsCode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssistantToolsCode to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			return d.Skip()
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode AssistantToolsCode")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssistantToolsCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssistantToolsCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssistantToolsFunction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssistantToolsFunction) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("function")
		s.Function.Encode(e)
	}
}

var jsonFieldsNameOfAssistantToolsFunction = [1]string{
	0: "function",
}

// Decode decodes AssistantToolsFunction from json.
func (s *AssistantToolsFunction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssistantToolsFunction to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "function":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Function.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"function\"")
			}
		case "type":
			return d.Skip()
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssistantToolsFunction")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAssistantToolsFunction) {
					name = jsonFieldsNameOfAssistantToolsFunction[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssistantToolsFunction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssistantToolsFunction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssistantToolsRetrieval) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssistantToolsRetrieval) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfAssistantToolsRetrieval = [0]string{}

// Decode decodes AssistantToolsRetrieval from json.
func (s *AssistantToolsRetrieval) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssistantToolsRetrieval to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			return d.Skip()
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode AssistantToolsRetrieval")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssistantToolsRetrieval) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssistantToolsRetrieval) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatCompletionFunctionCallOption) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatCompletionFunctionCallOption) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfChatCompletionFunctionCallOption = [1]string{
	0: "name",
}

// Decode decodes ChatCompletionFunctionCallOption from json.
func (s *ChatCompletionFunctionCallOption) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatCompletionFunctionCallOption to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatCompletionFunctionCallOption")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatCompletionFunctionCallOption) {
					name = jsonFieldsNameOfChatCompletionFunctionCallOption[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatCompletionFunctionCallOption) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatCompletionFunctionCallOption) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatCompletionFunctions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatCompletionFunctions) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Parameters.Set {
			e.FieldStart("parameters")
			s.Parameters.Encode(e)
		}
	}
}

var jsonFieldsNameOfChatCompletionFunctions = [3]string{
	0: "description",
	1: "name",
	2: "parameters",
}

// Decode decodes ChatCompletionFunctions from json.
func (s *ChatCompletionFunctions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatCompletionFunctions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters.Reset()
				if err := s.Parameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatCompletionFunctions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatCompletionFunctions) {
					name = jsonFieldsNameOfChatCompletionFunctions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatCompletionFunctions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatCompletionFunctions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatCompletionMessageToolCall) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatCompletionMessageToolCall) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("function")
		s.Function.Encode(e)
	}
}

var jsonFieldsNameOfChatCompletionMessageToolCall = [3]string{
	0: "id",
	1: "type",
	2: "function",
}

// Decode decodes ChatCompletionMessageToolCall from json.
func (s *ChatCompletionMessageToolCall) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatCompletionMessageToolCall to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "function":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Function.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"function\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatCompletionMessageToolCall")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatCompletionMessageToolCall) {
					name = jsonFieldsNameOfChatCompletionMessageToolCall[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatCompletionMessageToolCall) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatCompletionMessageToolCall) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatCompletionMessageToolCallFunction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatCompletionMessageToolCallFunction) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("arguments")
		e.Str(s.Arguments)
	}
}

var jsonFieldsNameOfChatCompletionMessageToolCallFunction = [2]string{
	0: "name",
	1: "arguments",
}

// Decode decodes ChatCompletionMessageToolCallFunction from json.
func (s *ChatCompletionMessageToolCallFunction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatCompletionMessageToolCallFunction to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "arguments":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Arguments = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"arguments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatCompletionMessageToolCallFunction")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatCompletionMessageToolCallFunction) {
					name = jsonFieldsNameOfChatCompletionMessageToolCallFunction[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatCompletionMessageToolCallFunction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatCompletionMessageToolCallFunction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatCompletionMessageToolCallType as json.
func (s ChatCompletionMessageToolCallType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ChatCompletionMessageToolCallType from json.
func (s *ChatCompletionMessageToolCallType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatCompletionMessageToolCallType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ChatCompletionMessageToolCallType(v) {
	case ChatCompletionMessageToolCallTypeFunction:
		*s = ChatCompletionMessageToolCallTypeFunction
	default:
		*s = ChatCompletionMessageToolCallType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ChatCompletionMessageToolCallType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatCompletionMessageToolCallType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatCompletionMessageToolCalls as json.
func (s ChatCompletionMessageToolCalls) Encode(e *jx.Encoder) {
	unwrapped := []ChatCompletionMessageToolCall(s)
	if unwrapped == nil {
		e.ArrEmpty()
		return
	}
	if unwrapped != nil {
		e.ArrStart()
		for _, elem := range unwrapped {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

// Decode decodes ChatCompletionMessageToolCalls from json.
func (s *ChatCompletionMessageToolCalls) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatCompletionMessageToolCalls to nil")
	}
	var unwrapped []ChatCompletionMessageToolCall
	if err := func() error {
		unwrapped = make([]ChatCompletionMessageToolCall, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ChatCompletionMessageToolCall
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ChatCompletionMessageToolCalls(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ChatCompletionMessageToolCalls) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatCompletionMessageToolCalls) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatCompletionNamedToolChoice) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatCompletionNamedToolChoice) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("function")
		s.Function.Encode(e)
	}
}

var jsonFieldsNameOfChatCompletionNamedToolChoice = [2]string{
	0: "type",
	1: "function",
}

// Decode decodes ChatCompletionNamedToolChoice from json.
func (s *ChatCompletionNamedToolChoice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatCompletionNamedToolChoice to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "function":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Function.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"function\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatCompletionNamedToolChoice")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatCompletionNamedToolChoice) {
					name = jsonFieldsNameOfChatCompletionNamedToolChoice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatCompletionNamedToolChoice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatCompletionNamedToolChoice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatCompletionNamedToolChoiceFunction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatCompletionNamedToolChoiceFunction) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfChatCompletionNamedToolChoiceFunction = [1]string{
	0: "name",
}

// Decode decodes ChatCompletionNamedToolChoiceFunction from json.
func (s *ChatCompletionNamedToolChoiceFunction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatCompletionNamedToolChoiceFunction to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatCompletionNamedToolChoiceFunction")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatCompletionNamedToolChoiceFunction) {
					name = jsonFieldsNameOfChatCompletionNamedToolChoiceFunction[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatCompletionNamedToolChoiceFunction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatCompletionNamedToolChoiceFunction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatCompletionNamedToolChoiceType as json.
func (s ChatCompletionNamedToolChoiceType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ChatCompletionNamedToolChoiceType from json.
func (s *ChatCompletionNamedToolChoiceType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatCompletionNamedToolChoiceType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ChatCompletionNamedToolChoiceType(v) {
	case ChatCompletionNamedToolChoiceTypeFunction:
		*s = ChatCompletionNamedToolChoiceTypeFunction
	default:
		*s = ChatCompletionNamedToolChoiceType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ChatCompletionNamedToolChoiceType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatCompletionNamedToolChoiceType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatCompletionRequestSystemMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatCompletionRequestSystemMessage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("content")
		e.Str(s.Content)
	}
	{
		e.FieldStart("role")
		s.Role.Encode(e)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfChatCompletionRequestSystemMessage = [3]string{
	0: "content",
	1: "role",
	2: "name",
}

// Decode decodes ChatCompletionRequestSystemMessage from json.
func (s *ChatCompletionRequestSystemMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatCompletionRequestSystemMessage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Content = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "role":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatCompletionRequestSystemMessage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatCompletionRequestSystemMessage) {
					name = jsonFieldsNameOfChatCompletionRequestSystemMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatCompletionRequestSystemMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatCompletionRequestSystemMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatCompletionRequestSystemMessageRole as json.
func (s ChatCompletionRequestSystemMessageRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ChatCompletionRequestSystemMessageRole from json.
func (s *ChatCompletionRequestSystemMessageRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatCompletionRequestSystemMessageRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ChatCompletionRequestSystemMessageRole(v) {
	case ChatCompletionRequestSystemMessageRoleSystem:
		*s = ChatCompletionRequestSystemMessageRoleSystem
	default:
		*s = ChatCompletionRequestSystemMessageRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ChatCompletionRequestSystemMessageRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatCompletionRequestSystemMessageRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatCompletionResponseMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatCompletionResponseMessage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("content")
		s.Content.Encode(e)
	}
	{
		if s.ToolCalls != nil {
			e.FieldStart("tool_calls")
			s.ToolCalls.Encode(e)
		}
	}
	{
		e.FieldStart("role")
		s.Role.Encode(e)
	}
	{
		if s.FunctionCall.Set {
			e.FieldStart("function_call")
			s.FunctionCall.Encode(e)
		}
	}
}

var jsonFieldsNameOfChatCompletionResponseMessage = [4]string{
	0: "content",
	1: "tool_calls",
	2: "role",
	3: "function_call",
}

// Decode decodes ChatCompletionResponseMessage from json.
func (s *ChatCompletionResponseMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatCompletionResponseMessage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "tool_calls":
			if err := func() error {
				if err := s.ToolCalls.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_calls\"")
			}
		case "role":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "function_call":
			if err := func() error {
				s.FunctionCall.Reset()
				if err := s.FunctionCall.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"function_call\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatCompletionResponseMessage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatCompletionResponseMessage) {
					name = jsonFieldsNameOfChatCompletionResponseMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatCompletionResponseMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatCompletionResponseMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatCompletionResponseMessageFunctionCall) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatCompletionResponseMessageFunctionCall) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("arguments")
		e.Str(s.Arguments)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfChatCompletionResponseMessageFunctionCall = [2]string{
	0: "arguments",
	1: "name",
}

// Decode decodes ChatCompletionResponseMessageFunctionCall from json.
func (s *ChatCompletionResponseMessageFunctionCall) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatCompletionResponseMessageFunctionCall to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "arguments":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Arguments = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"arguments\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatCompletionResponseMessageFunctionCall")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatCompletionResponseMessageFunctionCall) {
					name = jsonFieldsNameOfChatCompletionResponseMessageFunctionCall[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatCompletionResponseMessageFunctionCall) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatCompletionResponseMessageFunctionCall) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatCompletionResponseMessageRole as json.
func (s ChatCompletionResponseMessageRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ChatCompletionResponseMessageRole from json.
func (s *ChatCompletionResponseMessageRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatCompletionResponseMessageRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ChatCompletionResponseMessageRole(v) {
	case ChatCompletionResponseMessageRoleAssistant:
		*s = ChatCompletionResponseMessageRoleAssistant
	default:
		*s = ChatCompletionResponseMessageRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ChatCompletionResponseMessageRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatCompletionResponseMessageRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatCompletionTokenLogprob) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatCompletionTokenLogprob) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("token")
		e.Str(s.Token)
	}
	{
		e.FieldStart("logprob")
		e.Float64(s.Logprob)
	}
	{
		e.FieldStart("bytes")
		if s.Bytes == nil {
			e.Null()
		} else {
			e.ArrStart()
			for _, elem := range s.Bytes {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("top_logprobs")
		e.ArrStart()
		for _, elem := range s.TopLogprobs {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfChatCompletionTokenLogprob = [4]string{
	0: "token",
	1: "logprob",
	2: "bytes",
	3: "top_logprobs",
}

// Decode decodes ChatCompletionTokenLogprob from json.
func (s *ChatCompletionTokenLogprob) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatCompletionTokenLogprob to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "token":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Token = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		case "logprob":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Logprob = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logprob\"")
			}
		case "bytes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				switch tt := d.Next(); tt {
				case jx.Null:
					if err := d.Skip(); err != nil {
						return err
					}
				default:
					s.Bytes = make([]int, 0)
					if err := d.Arr(func(d *jx.Decoder) error {
						var elem int
						v, err := d.Int()
						elem = int(v)
						if err != nil {
							return err
						}
						s.Bytes = append(s.Bytes, elem)
						return nil
					}); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bytes\"")
			}
		case "top_logprobs":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.TopLogprobs = make([]ChatCompletionTokenLogprobTopLogprobsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ChatCompletionTokenLogprobTopLogprobsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.TopLogprobs = append(s.TopLogprobs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"top_logprobs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatCompletionTokenLogprob")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatCompletionTokenLogprob) {
					name = jsonFieldsNameOfChatCompletionTokenLogprob[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatCompletionTokenLogprob) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatCompletionTokenLogprob) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatCompletionTokenLogprobTopLogprobsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatCompletionTokenLogprobTopLogprobsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("token")
		e.Str(s.Token)
	}
	{
		e.FieldStart("logprob")
		e.Float64(s.Logprob)
	}
	{
		e.FieldStart("bytes")
		if s.Bytes == nil {
			e.Null()
		} else {
			e.ArrStart()
			for _, elem := range s.Bytes {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfChatCompletionTokenLogprobTopLogprobsItem = [3]string{
	0: "token",
	1: "logprob",
	2: "bytes",
}

// Decode decodes ChatCompletionTokenLogprobTopLogprobsItem from json.
func (s *ChatCompletionTokenLogprobTopLogprobsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatCompletionTokenLogprobTopLogprobsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "token":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Token = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		case "logprob":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Logprob = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logprob\"")
			}
		case "bytes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				switch tt := d.Next(); tt {
				case jx.Null:
					if err := d.Skip(); err != nil {
						return err
					}
				default:
					s.Bytes = make([]int, 0)
					if err := d.Arr(func(d *jx.Decoder) error {
						var elem int
						v, err := d.Int()
						elem = int(v)
						if err != nil {
							return err
						}
						s.Bytes = append(s.Bytes, elem)
						return nil
					}); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bytes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatCompletionTokenLogprobTopLogprobsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatCompletionTokenLogprobTopLogprobsItem) {
					name = jsonFieldsNameOfChatCompletionTokenLogprobTopLogprobsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatCompletionTokenLogprobTopLogprobsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatCompletionTokenLogprobTopLogprobsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatCompletionTool) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatCompletionTool) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("function")
		s.Function.Encode(e)
	}
}

var jsonFieldsNameOfChatCompletionTool = [2]string{
	0: "type",
	1: "function",
}

// Decode decodes ChatCompletionTool from json.
func (s *ChatCompletionTool) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatCompletionTool to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "function":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Function.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"function\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatCompletionTool")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChatCompletionTool) {
					name = jsonFieldsNameOfChatCompletionTool[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatCompletionTool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatCompletionTool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatCompletionToolChoiceOption as json.
func (s ChatCompletionToolChoiceOption) Encode(e *jx.Encoder) {
	switch s.Type {
	case ChatCompletionToolChoiceOption0ChatCompletionToolChoiceOption:
		s.ChatCompletionToolChoiceOption0.Encode(e)
	case ChatCompletionNamedToolChoiceChatCompletionToolChoiceOption:
		s.ChatCompletionNamedToolChoice.Encode(e)
	}
}

// Decode decodes ChatCompletionToolChoiceOption from json.
func (s *ChatCompletionToolChoiceOption) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatCompletionToolChoiceOption to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.ChatCompletionNamedToolChoice.Decode(d); err != nil {
			return err
		}
		s.Type = ChatCompletionNamedToolChoiceChatCompletionToolChoiceOption
	case jx.String:
		if err := s.ChatCompletionToolChoiceOption0.Decode(d); err != nil {
			return err
		}
		s.Type = ChatCompletionToolChoiceOption0ChatCompletionToolChoiceOption
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ChatCompletionToolChoiceOption) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatCompletionToolChoiceOption) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatCompletionToolChoiceOption0 as json.
func (s ChatCompletionToolChoiceOption0) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ChatCompletionToolChoiceOption0 from json.
func (s *ChatCompletionToolChoiceOption0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatCompletionToolChoiceOption0 to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ChatCompletionToolChoiceOption0(v) {
	case ChatCompletionToolChoiceOption0None:
		*s = ChatCompletionToolChoiceOption0None
	case ChatCompletionToolChoiceOption0Auto:
		*s = ChatCompletionToolChoiceOption0Auto
	default:
		*s = ChatCompletionToolChoiceOption0(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ChatCompletionToolChoiceOption0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatCompletionToolChoiceOption0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatCompletionToolType as json.
func (s ChatCompletionToolType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ChatCompletionToolType from json.
func (s *ChatCompletionToolType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatCompletionToolType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ChatCompletionToolType(v) {
	case ChatCompletionToolTypeFunction:
		*s = ChatCompletionToolTypeFunction
	default:
		*s = ChatCompletionToolType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ChatCompletionToolType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatCompletionToolType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CompletionUsage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CompletionUsage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("completion_tokens")
		e.Int(s.CompletionTokens)
	}
	{
		e.FieldStart("prompt_tokens")
		e.Int(s.PromptTokens)
	}
	{
		e.FieldStart("total_tokens")
		e.Int(s.TotalTokens)
	}
}

var jsonFieldsNameOfCompletionUsage = [3]string{
	0: "completion_tokens",
	1: "prompt_tokens",
	2: "total_tokens",
}

// Decode decodes CompletionUsage from json.
func (s *CompletionUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CompletionUsage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "completion_tokens":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.CompletionTokens = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completion_tokens\"")
			}
		case "prompt_tokens":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.PromptTokens = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prompt_tokens\"")
			}
		case "total_tokens":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.TotalTokens = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_tokens\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CompletionUsage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCompletionUsage) {
					name = jsonFieldsNameOfCompletionUsage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CompletionUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CompletionUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateAssistantFileRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateAssistantFileRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("file_id")
		e.Str(s.FileID)
	}
}

var jsonFieldsNameOfCreateAssistantFileRequest = [1]string{
	0: "file_id",
}

// Decode decodes CreateAssistantFileRequest from json.
func (s *CreateAssistantFileRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAssistantFileRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_id\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateAssistantFileRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateAssistantFileRequest) {
					name = jsonFieldsNameOfCreateAssistantFileRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAssistantFileRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAssistantFileRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateAssistantRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateAssistantRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("model")
		s.Model.Encode(e)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Instructions.Set {
			e.FieldStart("instructions")
			s.Instructions.Encode(e)
		}
	}
	{
		if s.Tools != nil {
			e.FieldStart("tools")
			e.ArrStart()
			for _, elem := range s.Tools {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.FileIds != nil {
			e.FieldStart("file_ids")
			e.ArrStart()
			for _, elem := range s.FileIds {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateAssistantRequest = [7]string{
	0: "model",
	1: "name",
	2: "description",
	3: "instructions",
	4: "tools",
	5: "file_ids",
	6: "metadata",
}

// Decode decodes CreateAssistantRequest from json.
func (s *CreateAssistantRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAssistantRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "model":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Model.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "instructions":
			if err := func() error {
				s.Instructions.Reset()
				if err := s.Instructions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instructions\"")
			}
		case "tools":
			if err := func() error {
				s.Tools = make([]CreateAssistantRequestToolsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateAssistantRequestToolsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tools = append(s.Tools, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tools\"")
			}
		case "file_ids":
			if err := func() error {
				s.FileIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.FileIds = append(s.FileIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_ids\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateAssistantRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateAssistantRequest) {
					name = jsonFieldsNameOfCreateAssistantRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAssistantRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAssistantRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateAssistantRequestMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateAssistantRequestMetadata) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateAssistantRequestMetadata = [0]string{}

// Decode decodes CreateAssistantRequestMetadata from json.
func (s *CreateAssistantRequestMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAssistantRequestMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CreateAssistantRequestMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAssistantRequestMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAssistantRequestMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAssistantRequestModel as json.
func (s CreateAssistantRequestModel) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringCreateAssistantRequestModel:
		e.Str(s.String)
	}
}

// Decode decodes CreateAssistantRequestModel from json.
func (s *CreateAssistantRequestModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAssistantRequestModel to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringCreateAssistantRequestModel
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateAssistantRequestModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAssistantRequestModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAssistantRequestToolsItem as json.
func (s CreateAssistantRequestToolsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s CreateAssistantRequestToolsItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case AssistantToolsCodeCreateAssistantRequestToolsItem:
		e.FieldStart("type")
		e.Str("code_interpreter")
		s.AssistantToolsCode.encodeFields(e)
	case AssistantToolsFunctionCreateAssistantRequestToolsItem:
		e.FieldStart("type")
		e.Str("function")
		s.AssistantToolsFunction.encodeFields(e)
	case AssistantToolsRetrievalCreateAssistantRequestToolsItem:
		e.FieldStart("type")
		e.Str("retrieval")
		s.AssistantToolsRetrieval.encodeFields(e)
	}
}

// Decode decodes CreateAssistantRequestToolsItem from json.
func (s *CreateAssistantRequestToolsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAssistantRequestToolsItem to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "code_interpreter":
					s.Type = AssistantToolsCodeCreateAssistantRequestToolsItem
					found = true
				case "function":
					s.Type = AssistantToolsFunctionCreateAssistantRequestToolsItem
					found = true
				case "retrieval":
					s.Type = AssistantToolsRetrievalCreateAssistantRequestToolsItem
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case AssistantToolsCodeCreateAssistantRequestToolsItem:
		if err := s.AssistantToolsCode.Decode(d); err != nil {
			return err
		}
	case AssistantToolsRetrievalCreateAssistantRequestToolsItem:
		if err := s.AssistantToolsRetrieval.Decode(d); err != nil {
			return err
		}
	case AssistantToolsFunctionCreateAssistantRequestToolsItem:
		if err := s.AssistantToolsFunction.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateAssistantRequestToolsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAssistantRequestToolsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateChatCompletionRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateChatCompletionRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("messages")
		e.ArrStart()
		for _, elem := range s.Messages {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("model")
		e.Str(s.Model)
	}
	{
		if s.FrequencyPenalty.Set {
			e.FieldStart("frequency_penalty")
			s.FrequencyPenalty.Encode(e)
		}
	}
	{
		if s.LogitBias.Set {
			e.FieldStart("logit_bias")
			s.LogitBias.Encode(e)
		}
	}
	{
		if s.Logprobs.Set {
			e.FieldStart("logprobs")
			s.Logprobs.Encode(e)
		}
	}
	{
		if s.TopLogprobs.Set {
			e.FieldStart("top_logprobs")
			s.TopLogprobs.Encode(e)
		}
	}
	{
		if s.MaxTokens.Set {
			e.FieldStart("max_tokens")
			s.MaxTokens.Encode(e)
		}
	}
	{
		if s.N.Set {
			e.FieldStart("n")
			s.N.Encode(e)
		}
	}
	{
		if s.PresencePenalty.Set {
			e.FieldStart("presence_penalty")
			s.PresencePenalty.Encode(e)
		}
	}
	{
		if s.ResponseFormat.Set {
			e.FieldStart("response_format")
			s.ResponseFormat.Encode(e)
		}
	}
	{
		if s.Seed.Set {
			e.FieldStart("seed")
			s.Seed.Encode(e)
		}
	}
	{
		if s.Stop.Set {
			e.FieldStart("stop")
			s.Stop.Encode(e)
		}
	}
	{
		if s.Stream.Set {
			e.FieldStart("stream")
			s.Stream.Encode(e)
		}
	}
	{
		if s.Temperature.Set {
			e.FieldStart("temperature")
			s.Temperature.Encode(e)
		}
	}
	{
		if s.TopP.Set {
			e.FieldStart("top_p")
			s.TopP.Encode(e)
		}
	}
	{
		if s.Tools != nil {
			e.FieldStart("tools")
			e.ArrStart()
			for _, elem := range s.Tools {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ToolChoice.Set {
			e.FieldStart("tool_choice")
			s.ToolChoice.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
	{
		if s.FunctionCall.Set {
			e.FieldStart("function_call")
			s.FunctionCall.Encode(e)
		}
	}
	{
		if s.Functions != nil {
			e.FieldStart("functions")
			e.ArrStart()
			for _, elem := range s.Functions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCreateChatCompletionRequest = [20]string{
	0:  "messages",
	1:  "model",
	2:  "frequency_penalty",
	3:  "logit_bias",
	4:  "logprobs",
	5:  "top_logprobs",
	6:  "max_tokens",
	7:  "n",
	8:  "presence_penalty",
	9:  "response_format",
	10: "seed",
	11: "stop",
	12: "stream",
	13: "temperature",
	14: "top_p",
	15: "tools",
	16: "tool_choice",
	17: "user",
	18: "function_call",
	19: "functions",
}

// Decode decodes CreateChatCompletionRequest from json.
func (s *CreateChatCompletionRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateChatCompletionRequest to nil")
	}
	var requiredBitSet [3]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "messages":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Messages = make([]ChatCompletionRequestSystemMessage, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ChatCompletionRequestSystemMessage
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Messages = append(s.Messages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"messages\"")
			}
		case "model":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Model = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		case "frequency_penalty":
			if err := func() error {
				s.FrequencyPenalty.Reset()
				if err := s.FrequencyPenalty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"frequency_penalty\"")
			}
		case "logit_bias":
			if err := func() error {
				s.LogitBias.Reset()
				if err := s.LogitBias.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logit_bias\"")
			}
		case "logprobs":
			if err := func() error {
				s.Logprobs.Reset()
				if err := s.Logprobs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logprobs\"")
			}
		case "top_logprobs":
			if err := func() error {
				s.TopLogprobs.Reset()
				if err := s.TopLogprobs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"top_logprobs\"")
			}
		case "max_tokens":
			if err := func() error {
				s.MaxTokens.Reset()
				if err := s.MaxTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_tokens\"")
			}
		case "n":
			if err := func() error {
				s.N.Reset()
				if err := s.N.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"n\"")
			}
		case "presence_penalty":
			if err := func() error {
				s.PresencePenalty.Reset()
				if err := s.PresencePenalty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"presence_penalty\"")
			}
		case "response_format":
			if err := func() error {
				s.ResponseFormat.Reset()
				if err := s.ResponseFormat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response_format\"")
			}
		case "seed":
			if err := func() error {
				s.Seed.Reset()
				if err := s.Seed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seed\"")
			}
		case "stop":
			if err := func() error {
				s.Stop.Reset()
				if err := s.Stop.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stop\"")
			}
		case "stream":
			if err := func() error {
				s.Stream.Reset()
				if err := s.Stream.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stream\"")
			}
		case "temperature":
			if err := func() error {
				s.Temperature.Reset()
				if err := s.Temperature.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temperature\"")
			}
		case "top_p":
			if err := func() error {
				s.TopP.Reset()
				if err := s.TopP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"top_p\"")
			}
		case "tools":
			if err := func() error {
				s.Tools = make([]ChatCompletionTool, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ChatCompletionTool
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tools = append(s.Tools, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tools\"")
			}
		case "tool_choice":
			if err := func() error {
				s.ToolChoice.Reset()
				if err := s.ToolChoice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_choice\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "function_call":
			if err := func() error {
				s.FunctionCall.Reset()
				if err := s.FunctionCall.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"function_call\"")
			}
		case "functions":
			if err := func() error {
				s.Functions = make([]ChatCompletionFunctions, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ChatCompletionFunctions
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Functions = append(s.Functions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"functions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateChatCompletionRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000011,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateChatCompletionRequest) {
					name = jsonFieldsNameOfCreateChatCompletionRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateChatCompletionRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateChatCompletionRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateChatCompletionRequestFunctionCall as json.
func (s CreateChatCompletionRequestFunctionCall) Encode(e *jx.Encoder) {
	switch s.Type {
	case CreateChatCompletionRequestFunctionCall0CreateChatCompletionRequestFunctionCall:
		s.CreateChatCompletionRequestFunctionCall0.Encode(e)
	case ChatCompletionFunctionCallOptionCreateChatCompletionRequestFunctionCall:
		s.ChatCompletionFunctionCallOption.Encode(e)
	}
}

// Decode decodes CreateChatCompletionRequestFunctionCall from json.
func (s *CreateChatCompletionRequestFunctionCall) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateChatCompletionRequestFunctionCall to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.ChatCompletionFunctionCallOption.Decode(d); err != nil {
			return err
		}
		s.Type = ChatCompletionFunctionCallOptionCreateChatCompletionRequestFunctionCall
	case jx.String:
		if err := s.CreateChatCompletionRequestFunctionCall0.Decode(d); err != nil {
			return err
		}
		s.Type = CreateChatCompletionRequestFunctionCall0CreateChatCompletionRequestFunctionCall
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateChatCompletionRequestFunctionCall) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateChatCompletionRequestFunctionCall) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateChatCompletionRequestFunctionCall0 as json.
func (s CreateChatCompletionRequestFunctionCall0) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateChatCompletionRequestFunctionCall0 from json.
func (s *CreateChatCompletionRequestFunctionCall0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateChatCompletionRequestFunctionCall0 to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateChatCompletionRequestFunctionCall0(v) {
	case CreateChatCompletionRequestFunctionCall0None:
		*s = CreateChatCompletionRequestFunctionCall0None
	case CreateChatCompletionRequestFunctionCall0Auto:
		*s = CreateChatCompletionRequestFunctionCall0Auto
	default:
		*s = CreateChatCompletionRequestFunctionCall0(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateChatCompletionRequestFunctionCall0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateChatCompletionRequestFunctionCall0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s CreateChatCompletionRequestLogitBias) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s CreateChatCompletionRequestLogitBias) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Int(elem)
	}
}

// Decode decodes CreateChatCompletionRequestLogitBias from json.
func (s *CreateChatCompletionRequestLogitBias) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateChatCompletionRequestLogitBias to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem int
		if err := func() error {
			v, err := d.Int()
			elem = int(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateChatCompletionRequestLogitBias")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateChatCompletionRequestLogitBias) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateChatCompletionRequestLogitBias) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateChatCompletionRequestResponseFormat) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateChatCompletionRequestResponseFormat) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateChatCompletionRequestResponseFormat = [1]string{
	0: "type",
}

// Decode decodes CreateChatCompletionRequestResponseFormat from json.
func (s *CreateChatCompletionRequestResponseFormat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateChatCompletionRequestResponseFormat to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateChatCompletionRequestResponseFormat")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateChatCompletionRequestResponseFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateChatCompletionRequestResponseFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateChatCompletionRequestResponseFormatType as json.
func (s CreateChatCompletionRequestResponseFormatType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateChatCompletionRequestResponseFormatType from json.
func (s *CreateChatCompletionRequestResponseFormatType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateChatCompletionRequestResponseFormatType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateChatCompletionRequestResponseFormatType(v) {
	case CreateChatCompletionRequestResponseFormatTypeText:
		*s = CreateChatCompletionRequestResponseFormatTypeText
	case CreateChatCompletionRequestResponseFormatTypeJSONObject:
		*s = CreateChatCompletionRequestResponseFormatTypeJSONObject
	default:
		*s = CreateChatCompletionRequestResponseFormatType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateChatCompletionRequestResponseFormatType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateChatCompletionRequestResponseFormatType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateChatCompletionRequestStop as json.
func (s CreateChatCompletionRequestStop) Encode(e *jx.Encoder) {
	switch s.Type {
	case NullCreateChatCompletionRequestStop:
		_ = s.Null
		e.Null()
	case StringCreateChatCompletionRequestStop:
		e.Str(s.String)
	case StringArrayCreateChatCompletionRequestStop:
		e.ArrStart()
		for _, elem := range s.StringArray {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes CreateChatCompletionRequestStop from json.
func (s *CreateChatCompletionRequestStop) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateChatCompletionRequestStop to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Array:
		s.StringArray = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.StringArray = append(s.StringArray, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = StringArrayCreateChatCompletionRequestStop
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullCreateChatCompletionRequestStop
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringCreateChatCompletionRequestStop
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateChatCompletionRequestStop) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateChatCompletionRequestStop) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateChatCompletionResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateChatCompletionResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("choices")
		e.ArrStart()
		for _, elem := range s.Choices {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("created")
		e.Int(s.Created)
	}
	{
		e.FieldStart("model")
		e.Str(s.Model)
	}
	{
		if s.SystemFingerprint.Set {
			e.FieldStart("system_fingerprint")
			s.SystemFingerprint.Encode(e)
		}
	}
	{
		e.FieldStart("object")
		s.Object.Encode(e)
	}
	{
		if s.Usage.Set {
			e.FieldStart("usage")
			s.Usage.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateChatCompletionResponse = [7]string{
	0: "id",
	1: "choices",
	2: "created",
	3: "model",
	4: "system_fingerprint",
	5: "object",
	6: "usage",
}

// Decode decodes CreateChatCompletionResponse from json.
func (s *CreateChatCompletionResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateChatCompletionResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "choices":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Choices = make([]CreateChatCompletionResponseChoicesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateChatCompletionResponseChoicesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Choices = append(s.Choices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"choices\"")
			}
		case "created":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Created = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created\"")
			}
		case "model":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Model = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		case "system_fingerprint":
			if err := func() error {
				s.SystemFingerprint.Reset()
				if err := s.SystemFingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"system_fingerprint\"")
			}
		case "object":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "usage":
			if err := func() error {
				s.Usage.Reset()
				if err := s.Usage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateChatCompletionResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00101111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateChatCompletionResponse) {
					name = jsonFieldsNameOfCreateChatCompletionResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateChatCompletionResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateChatCompletionResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateChatCompletionResponseChoicesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateChatCompletionResponseChoicesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("finish_reason")
		s.FinishReason.Encode(e)
	}
	{
		e.FieldStart("index")
		e.Int(s.Index)
	}
	{
		e.FieldStart("message")
		s.Message.Encode(e)
	}
	{
		e.FieldStart("logprobs")
		s.Logprobs.Encode(e)
	}
}

var jsonFieldsNameOfCreateChatCompletionResponseChoicesItem = [4]string{
	0: "finish_reason",
	1: "index",
	2: "message",
	3: "logprobs",
}

// Decode decodes CreateChatCompletionResponseChoicesItem from json.
func (s *CreateChatCompletionResponseChoicesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateChatCompletionResponseChoicesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "finish_reason":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.FinishReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finish_reason\"")
			}
		case "index":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Index = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"index\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "logprobs":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Logprobs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logprobs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateChatCompletionResponseChoicesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateChatCompletionResponseChoicesItem) {
					name = jsonFieldsNameOfCreateChatCompletionResponseChoicesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateChatCompletionResponseChoicesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateChatCompletionResponseChoicesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateChatCompletionResponseChoicesItemFinishReason as json.
func (s CreateChatCompletionResponseChoicesItemFinishReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateChatCompletionResponseChoicesItemFinishReason from json.
func (s *CreateChatCompletionResponseChoicesItemFinishReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateChatCompletionResponseChoicesItemFinishReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateChatCompletionResponseChoicesItemFinishReason(v) {
	case CreateChatCompletionResponseChoicesItemFinishReasonStop:
		*s = CreateChatCompletionResponseChoicesItemFinishReasonStop
	case CreateChatCompletionResponseChoicesItemFinishReasonLength:
		*s = CreateChatCompletionResponseChoicesItemFinishReasonLength
	case CreateChatCompletionResponseChoicesItemFinishReasonToolCalls:
		*s = CreateChatCompletionResponseChoicesItemFinishReasonToolCalls
	case CreateChatCompletionResponseChoicesItemFinishReasonContentFilter:
		*s = CreateChatCompletionResponseChoicesItemFinishReasonContentFilter
	case CreateChatCompletionResponseChoicesItemFinishReasonFunctionCall:
		*s = CreateChatCompletionResponseChoicesItemFinishReasonFunctionCall
	default:
		*s = CreateChatCompletionResponseChoicesItemFinishReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateChatCompletionResponseChoicesItemFinishReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateChatCompletionResponseChoicesItemFinishReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateChatCompletionResponseChoicesItemLogprobs) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateChatCompletionResponseChoicesItemLogprobs) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("content")
		if s.Content == nil {
			e.Null()
		} else {
			e.ArrStart()
			for _, elem := range s.Content {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCreateChatCompletionResponseChoicesItemLogprobs = [1]string{
	0: "content",
}

// Decode decodes CreateChatCompletionResponseChoicesItemLogprobs from json.
func (s *CreateChatCompletionResponseChoicesItemLogprobs) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateChatCompletionResponseChoicesItemLogprobs to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				switch tt := d.Next(); tt {
				case jx.Null:
					if err := d.Skip(); err != nil {
						return err
					}
				default:
					s.Content = make([]ChatCompletionTokenLogprob, 0)
					if err := d.Arr(func(d *jx.Decoder) error {
						var elem ChatCompletionTokenLogprob
						if err := elem.Decode(d); err != nil {
							return err
						}
						s.Content = append(s.Content, elem)
						return nil
					}); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateChatCompletionResponseChoicesItemLogprobs")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateChatCompletionResponseChoicesItemLogprobs) {
					name = jsonFieldsNameOfCreateChatCompletionResponseChoicesItemLogprobs[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateChatCompletionResponseChoicesItemLogprobs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateChatCompletionResponseChoicesItemLogprobs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateChatCompletionResponseObject as json.
func (s CreateChatCompletionResponseObject) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateChatCompletionResponseObject from json.
func (s *CreateChatCompletionResponseObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateChatCompletionResponseObject to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateChatCompletionResponseObject(v) {
	case CreateChatCompletionResponseObjectChatCompletion:
		*s = CreateChatCompletionResponseObjectChatCompletion
	default:
		*s = CreateChatCompletionResponseObject(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateChatCompletionResponseObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateChatCompletionResponseObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateFineTuningJobRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateFineTuningJobRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("model")
		e.Str(s.Model)
	}
	{
		e.FieldStart("training_file")
		e.Str(s.TrainingFile)
	}
	{
		if s.Hyperparameters.Set {
			e.FieldStart("hyperparameters")
			s.Hyperparameters.Encode(e)
		}
	}
	{
		if s.Suffix.Set {
			e.FieldStart("suffix")
			s.Suffix.Encode(e)
		}
	}
	{
		if s.ValidationFile.Set {
			e.FieldStart("validation_file")
			s.ValidationFile.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateFineTuningJobRequest = [5]string{
	0: "model",
	1: "training_file",
	2: "hyperparameters",
	3: "suffix",
	4: "validation_file",
}

// Decode decodes CreateFineTuningJobRequest from json.
func (s *CreateFineTuningJobRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateFineTuningJobRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "model":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Model = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		case "training_file":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TrainingFile = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"training_file\"")
			}
		case "hyperparameters":
			if err := func() error {
				s.Hyperparameters.Reset()
				if err := s.Hyperparameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hyperparameters\"")
			}
		case "suffix":
			if err := func() error {
				s.Suffix.Reset()
				if err := s.Suffix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"suffix\"")
			}
		case "validation_file":
			if err := func() error {
				s.ValidationFile.Reset()
				if err := s.ValidationFile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validation_file\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateFineTuningJobRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateFineTuningJobRequest) {
					name = jsonFieldsNameOfCreateFineTuningJobRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateFineTuningJobRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateFineTuningJobRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateFineTuningJobRequestHyperparameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateFineTuningJobRequestHyperparameters) encodeFields(e *jx.Encoder) {
	{
		if s.BatchSize.Set {
			e.FieldStart("batch_size")
			s.BatchSize.Encode(e)
		}
	}
	{
		if s.LearningRateMultiplier.Set {
			e.FieldStart("learning_rate_multiplier")
			s.LearningRateMultiplier.Encode(e)
		}
	}
	{
		if s.NEpochs.Set {
			e.FieldStart("n_epochs")
			s.NEpochs.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateFineTuningJobRequestHyperparameters = [3]string{
	0: "batch_size",
	1: "learning_rate_multiplier",
	2: "n_epochs",
}

// Decode decodes CreateFineTuningJobRequestHyperparameters from json.
func (s *CreateFineTuningJobRequestHyperparameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateFineTuningJobRequestHyperparameters to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "batch_size":
			if err := func() error {
				s.BatchSize.Reset()
				if err := s.BatchSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"batch_size\"")
			}
		case "learning_rate_multiplier":
			if err := func() error {
				s.LearningRateMultiplier.Reset()
				if err := s.LearningRateMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"learning_rate_multiplier\"")
			}
		case "n_epochs":
			if err := func() error {
				s.NEpochs.Reset()
				if err := s.NEpochs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"n_epochs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateFineTuningJobRequestHyperparameters")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateFineTuningJobRequestHyperparameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateFineTuningJobRequestHyperparameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateFineTuningJobRequestHyperparametersBatchSize as json.
func (s CreateFineTuningJobRequestHyperparametersBatchSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case CreateFineTuningJobRequestHyperparametersBatchSize0CreateFineTuningJobRequestHyperparametersBatchSize:
		s.CreateFineTuningJobRequestHyperparametersBatchSize0.Encode(e)
	case IntCreateFineTuningJobRequestHyperparametersBatchSize:
		e.Int(s.Int)
	}
}

// Decode decodes CreateFineTuningJobRequestHyperparametersBatchSize from json.
func (s *CreateFineTuningJobRequestHyperparametersBatchSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateFineTuningJobRequestHyperparametersBatchSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntCreateFineTuningJobRequestHyperparametersBatchSize
	case jx.String:
		if err := s.CreateFineTuningJobRequestHyperparametersBatchSize0.Decode(d); err != nil {
			return err
		}
		s.Type = CreateFineTuningJobRequestHyperparametersBatchSize0CreateFineTuningJobRequestHyperparametersBatchSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateFineTuningJobRequestHyperparametersBatchSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateFineTuningJobRequestHyperparametersBatchSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateFineTuningJobRequestHyperparametersBatchSize0 as json.
func (s CreateFineTuningJobRequestHyperparametersBatchSize0) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateFineTuningJobRequestHyperparametersBatchSize0 from json.
func (s *CreateFineTuningJobRequestHyperparametersBatchSize0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateFineTuningJobRequestHyperparametersBatchSize0 to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateFineTuningJobRequestHyperparametersBatchSize0(v) {
	case CreateFineTuningJobRequestHyperparametersBatchSize0Auto:
		*s = CreateFineTuningJobRequestHyperparametersBatchSize0Auto
	default:
		*s = CreateFineTuningJobRequestHyperparametersBatchSize0(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateFineTuningJobRequestHyperparametersBatchSize0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateFineTuningJobRequestHyperparametersBatchSize0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateFineTuningJobRequestHyperparametersLearningRateMultiplier as json.
func (s CreateFineTuningJobRequestHyperparametersLearningRateMultiplier) Encode(e *jx.Encoder) {
	switch s.Type {
	case CreateFineTuningJobRequestHyperparametersLearningRateMultiplier0CreateFineTuningJobRequestHyperparametersLearningRateMultiplier:
		s.CreateFineTuningJobRequestHyperparametersLearningRateMultiplier0.Encode(e)
	case Float64CreateFineTuningJobRequestHyperparametersLearningRateMultiplier:
		e.Float64(s.Float64)
	}
}

// Decode decodes CreateFineTuningJobRequestHyperparametersLearningRateMultiplier from json.
func (s *CreateFineTuningJobRequestHyperparametersLearningRateMultiplier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateFineTuningJobRequestHyperparametersLearningRateMultiplier to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Float64()
		s.Float64 = float64(v)
		if err != nil {
			return err
		}
		s.Type = Float64CreateFineTuningJobRequestHyperparametersLearningRateMultiplier
	case jx.String:
		if err := s.CreateFineTuningJobRequestHyperparametersLearningRateMultiplier0.Decode(d); err != nil {
			return err
		}
		s.Type = CreateFineTuningJobRequestHyperparametersLearningRateMultiplier0CreateFineTuningJobRequestHyperparametersLearningRateMultiplier
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateFineTuningJobRequestHyperparametersLearningRateMultiplier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateFineTuningJobRequestHyperparametersLearningRateMultiplier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateFineTuningJobRequestHyperparametersLearningRateMultiplier0 as json.
func (s CreateFineTuningJobRequestHyperparametersLearningRateMultiplier0) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateFineTuningJobRequestHyperparametersLearningRateMultiplier0 from json.
func (s *CreateFineTuningJobRequestHyperparametersLearningRateMultiplier0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateFineTuningJobRequestHyperparametersLearningRateMultiplier0 to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateFineTuningJobRequestHyperparametersLearningRateMultiplier0(v) {
	case CreateFineTuningJobRequestHyperparametersLearningRateMultiplier0Auto:
		*s = CreateFineTuningJobRequestHyperparametersLearningRateMultiplier0Auto
	default:
		*s = CreateFineTuningJobRequestHyperparametersLearningRateMultiplier0(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateFineTuningJobRequestHyperparametersLearningRateMultiplier0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateFineTuningJobRequestHyperparametersLearningRateMultiplier0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateFineTuningJobRequestHyperparametersNEpochs as json.
func (s CreateFineTuningJobRequestHyperparametersNEpochs) Encode(e *jx.Encoder) {
	switch s.Type {
	case CreateFineTuningJobRequestHyperparametersNEpochs0CreateFineTuningJobRequestHyperparametersNEpochs:
		s.CreateFineTuningJobRequestHyperparametersNEpochs0.Encode(e)
	case IntCreateFineTuningJobRequestHyperparametersNEpochs:
		e.Int(s.Int)
	}
}

// Decode decodes CreateFineTuningJobRequestHyperparametersNEpochs from json.
func (s *CreateFineTuningJobRequestHyperparametersNEpochs) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateFineTuningJobRequestHyperparametersNEpochs to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntCreateFineTuningJobRequestHyperparametersNEpochs
	case jx.String:
		if err := s.CreateFineTuningJobRequestHyperparametersNEpochs0.Decode(d); err != nil {
			return err
		}
		s.Type = CreateFineTuningJobRequestHyperparametersNEpochs0CreateFineTuningJobRequestHyperparametersNEpochs
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateFineTuningJobRequestHyperparametersNEpochs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateFineTuningJobRequestHyperparametersNEpochs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateFineTuningJobRequestHyperparametersNEpochs0 as json.
func (s CreateFineTuningJobRequestHyperparametersNEpochs0) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateFineTuningJobRequestHyperparametersNEpochs0 from json.
func (s *CreateFineTuningJobRequestHyperparametersNEpochs0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateFineTuningJobRequestHyperparametersNEpochs0 to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateFineTuningJobRequestHyperparametersNEpochs0(v) {
	case CreateFineTuningJobRequestHyperparametersNEpochs0Auto:
		*s = CreateFineTuningJobRequestHyperparametersNEpochs0Auto
	default:
		*s = CreateFineTuningJobRequestHyperparametersNEpochs0(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateFineTuningJobRequestHyperparametersNEpochs0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateFineTuningJobRequestHyperparametersNEpochs0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateImageRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateImageRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("prompt")
		e.Str(s.Prompt)
	}
	{
		if s.Model.Set {
			e.FieldStart("model")
			s.Model.Encode(e)
		}
	}
	{
		if s.N.Set {
			e.FieldStart("n")
			s.N.Encode(e)
		}
	}
	{
		if s.Quality.Set {
			e.FieldStart("quality")
			s.Quality.Encode(e)
		}
	}
	{
		if s.ResponseFormat.Set {
			e.FieldStart("response_format")
			s.ResponseFormat.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.Style.Set {
			e.FieldStart("style")
			s.Style.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateImageRequest = [8]string{
	0: "prompt",
	1: "model",
	2: "n",
	3: "quality",
	4: "response_format",
	5: "size",
	6: "style",
	7: "user",
}

// Decode decodes CreateImageRequest from json.
func (s *CreateImageRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateImageRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "prompt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Prompt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prompt\"")
			}
		case "model":
			if err := func() error {
				s.Model.Reset()
				if err := s.Model.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		case "n":
			if err := func() error {
				s.N.Reset()
				if err := s.N.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"n\"")
			}
		case "quality":
			if err := func() error {
				s.Quality.Reset()
				if err := s.Quality.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quality\"")
			}
		case "response_format":
			if err := func() error {
				s.ResponseFormat.Reset()
				if err := s.ResponseFormat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response_format\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "style":
			if err := func() error {
				s.Style.Reset()
				if err := s.Style.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"style\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateImageRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateImageRequest) {
					name = jsonFieldsNameOfCreateImageRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateImageRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateImageRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateImageRequestQuality as json.
func (s CreateImageRequestQuality) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateImageRequestQuality from json.
func (s *CreateImageRequestQuality) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateImageRequestQuality to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateImageRequestQuality(v) {
	case CreateImageRequestQualityStandard:
		*s = CreateImageRequestQualityStandard
	case CreateImageRequestQualityHd:
		*s = CreateImageRequestQualityHd
	default:
		*s = CreateImageRequestQuality(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateImageRequestQuality) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateImageRequestQuality) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateImageRequestResponseFormat as json.
func (s CreateImageRequestResponseFormat) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateImageRequestResponseFormat from json.
func (s *CreateImageRequestResponseFormat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateImageRequestResponseFormat to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateImageRequestResponseFormat(v) {
	case CreateImageRequestResponseFormatURL:
		*s = CreateImageRequestResponseFormatURL
	case CreateImageRequestResponseFormatB64JSON:
		*s = CreateImageRequestResponseFormatB64JSON
	default:
		*s = CreateImageRequestResponseFormat(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateImageRequestResponseFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateImageRequestResponseFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateImageRequestSize as json.
func (s CreateImageRequestSize) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateImageRequestSize from json.
func (s *CreateImageRequestSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateImageRequestSize to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateImageRequestSize(v) {
	case CreateImageRequestSize256x256:
		*s = CreateImageRequestSize256x256
	case CreateImageRequestSize512x512:
		*s = CreateImageRequestSize512x512
	case CreateImageRequestSize1024x1024:
		*s = CreateImageRequestSize1024x1024
	case CreateImageRequestSize1792x1024:
		*s = CreateImageRequestSize1792x1024
	case CreateImageRequestSize1024x1792:
		*s = CreateImageRequestSize1024x1792
	default:
		*s = CreateImageRequestSize(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateImageRequestSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateImageRequestSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateImageRequestStyle as json.
func (s CreateImageRequestStyle) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateImageRequestStyle from json.
func (s *CreateImageRequestStyle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateImageRequestStyle to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateImageRequestStyle(v) {
	case CreateImageRequestStyleVivid:
		*s = CreateImageRequestStyleVivid
	case CreateImageRequestStyleNatural:
		*s = CreateImageRequestStyleNatural
	default:
		*s = CreateImageRequestStyle(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateImageRequestStyle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateImageRequestStyle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateMessageRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateMessageRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("role")
		s.Role.Encode(e)
	}
	{
		e.FieldStart("content")
		e.Str(s.Content)
	}
	{
		if s.FileIds != nil {
			e.FieldStart("file_ids")
			e.ArrStart()
			for _, elem := range s.FileIds {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateMessageRequest = [4]string{
	0: "role",
	1: "content",
	2: "file_ids",
	3: "metadata",
}

// Decode decodes CreateMessageRequest from json.
func (s *CreateMessageRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateMessageRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "role":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "content":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Content = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "file_ids":
			if err := func() error {
				s.FileIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.FileIds = append(s.FileIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_ids\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateMessageRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateMessageRequest) {
					name = jsonFieldsNameOfCreateMessageRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateMessageRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateMessageRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateMessageRequestMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateMessageRequestMetadata) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateMessageRequestMetadata = [0]string{}

// Decode decodes CreateMessageRequestMetadata from json.
func (s *CreateMessageRequestMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateMessageRequestMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CreateMessageRequestMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateMessageRequestMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateMessageRequestMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateMessageRequestRole as json.
func (s CreateMessageRequestRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateMessageRequestRole from json.
func (s *CreateMessageRequestRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateMessageRequestRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateMessageRequestRole(v) {
	case CreateMessageRequestRoleUser:
		*s = CreateMessageRequestRoleUser
	default:
		*s = CreateMessageRequestRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateMessageRequestRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateMessageRequestRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateModerationRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateModerationRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("input")
		s.Input.Encode(e)
	}
	{
		if s.Model.Set {
			e.FieldStart("model")
			s.Model.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateModerationRequest = [2]string{
	0: "input",
	1: "model",
}

// Decode decodes CreateModerationRequest from json.
func (s *CreateModerationRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateModerationRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "input":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Input.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input\"")
			}
		case "model":
			if err := func() error {
				s.Model.Reset()
				if err := s.Model.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateModerationRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateModerationRequest) {
					name = jsonFieldsNameOfCreateModerationRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateModerationRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateModerationRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateModerationRequestInput as json.
func (s CreateModerationRequestInput) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringCreateModerationRequestInput:
		e.Str(s.String)
	case StringArrayCreateModerationRequestInput:
		e.ArrStart()
		for _, elem := range s.StringArray {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes CreateModerationRequestInput from json.
func (s *CreateModerationRequestInput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateModerationRequestInput to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Array:
		s.StringArray = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.StringArray = append(s.StringArray, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = StringArrayCreateModerationRequestInput
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringCreateModerationRequestInput
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateModerationRequestInput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateModerationRequestInput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateModerationResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateModerationResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("model")
		e.Str(s.Model)
	}
	{
		e.FieldStart("results")
		e.ArrStart()
		for _, elem := range s.Results {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCreateModerationResponse = [3]string{
	0: "id",
	1: "model",
	2: "results",
}

// Decode decodes CreateModerationResponse from json.
func (s *CreateModerationResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateModerationResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "model":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Model = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		case "results":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Results = make([]CreateModerationResponseResultsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateModerationResponseResultsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Results = append(s.Results, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateModerationResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateModerationResponse) {
					name = jsonFieldsNameOfCreateModerationResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateModerationResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateModerationResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateModerationResponseResultsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateModerationResponseResultsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("flagged")
		e.Bool(s.Flagged)
	}
	{
		e.FieldStart("categories")
		s.Categories.Encode(e)
	}
	{
		e.FieldStart("category_scores")
		s.CategoryScores.Encode(e)
	}
}

var jsonFieldsNameOfCreateModerationResponseResultsItem = [3]string{
	0: "flagged",
	1: "categories",
	2: "category_scores",
}

// Decode decodes CreateModerationResponseResultsItem from json.
func (s *CreateModerationResponseResultsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateModerationResponseResultsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "flagged":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Flagged = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flagged\"")
			}
		case "categories":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Categories.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"categories\"")
			}
		case "category_scores":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.CategoryScores.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category_scores\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateModerationResponseResultsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateModerationResponseResultsItem) {
					name = jsonFieldsNameOfCreateModerationResponseResultsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateModerationResponseResultsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateModerationResponseResultsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateModerationResponseResultsItemCategories) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateModerationResponseResultsItemCategories) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("hate")
		e.Bool(s.Hate)
	}
	{
		e.FieldStart("hate/threatening")
		e.Bool(s.HateSlashThreatening)
	}
	{
		e.FieldStart("harassment")
		e.Bool(s.Harassment)
	}
	{
		e.FieldStart("harassment/threatening")
		e.Bool(s.HarassmentSlashThreatening)
	}
	{
		e.FieldStart("self-harm")
		e.Bool(s.SelfMinusHarm)
	}
	{
		e.FieldStart("self-harm/intent")
		e.Bool(s.SelfMinusHarmSlashIntent)
	}
	{
		e.FieldStart("self-harm/instructions")
		e.Bool(s.SelfMinusHarmSlashInstructions)
	}
	{
		e.FieldStart("sexual")
		e.Bool(s.Sexual)
	}
	{
		e.FieldStart("sexual/minors")
		e.Bool(s.SexualSlashMinors)
	}
	{
		e.FieldStart("violence")
		e.Bool(s.Violence)
	}
	{
		e.FieldStart("violence/graphic")
		e.Bool(s.ViolenceSlashGraphic)
	}
}

var jsonFieldsNameOfCreateModerationResponseResultsItemCategories = [11]string{
	0:  "hate",
	1:  "hate/threatening",
	2:  "harassment",
	3:  "harassment/threatening",
	4:  "self-harm",
	5:  "self-harm/intent",
	6:  "self-harm/instructions",
	7:  "sexual",
	8:  "sexual/minors",
	9:  "violence",
	10: "violence/graphic",
}

// Decode decodes CreateModerationResponseResultsItemCategories from json.
func (s *CreateModerationResponseResultsItemCategories) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateModerationResponseResultsItemCategories to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hate":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Hate = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hate\"")
			}
		case "hate/threatening":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HateSlashThreatening = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hate/threatening\"")
			}
		case "harassment":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Harassment = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"harassment\"")
			}
		case "harassment/threatening":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.HarassmentSlashThreatening = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"harassment/threatening\"")
			}
		case "self-harm":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.SelfMinusHarm = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"self-harm\"")
			}
		case "self-harm/intent":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.SelfMinusHarmSlashIntent = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"self-harm/intent\"")
			}
		case "self-harm/instructions":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.SelfMinusHarmSlashInstructions = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"self-harm/instructions\"")
			}
		case "sexual":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.Sexual = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sexual\"")
			}
		case "sexual/minors":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.SexualSlashMinors = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sexual/minors\"")
			}
		case "violence":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Violence = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"violence\"")
			}
		case "violence/graphic":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.ViolenceSlashGraphic = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"violence/graphic\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateModerationResponseResultsItemCategories")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateModerationResponseResultsItemCategories) {
					name = jsonFieldsNameOfCreateModerationResponseResultsItemCategories[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateModerationResponseResultsItemCategories) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateModerationResponseResultsItemCategories) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateModerationResponseResultsItemCategoryScores) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateModerationResponseResultsItemCategoryScores) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("hate")
		e.Float64(s.Hate)
	}
	{
		e.FieldStart("hate/threatening")
		e.Float64(s.HateSlashThreatening)
	}
	{
		e.FieldStart("harassment")
		e.Float64(s.Harassment)
	}
	{
		e.FieldStart("harassment/threatening")
		e.Float64(s.HarassmentSlashThreatening)
	}
	{
		e.FieldStart("self-harm")
		e.Float64(s.SelfMinusHarm)
	}
	{
		e.FieldStart("self-harm/intent")
		e.Float64(s.SelfMinusHarmSlashIntent)
	}
	{
		e.FieldStart("self-harm/instructions")
		e.Float64(s.SelfMinusHarmSlashInstructions)
	}
	{
		e.FieldStart("sexual")
		e.Float64(s.Sexual)
	}
	{
		e.FieldStart("sexual/minors")
		e.Float64(s.SexualSlashMinors)
	}
	{
		e.FieldStart("violence")
		e.Float64(s.Violence)
	}
	{
		e.FieldStart("violence/graphic")
		e.Float64(s.ViolenceSlashGraphic)
	}
}

var jsonFieldsNameOfCreateModerationResponseResultsItemCategoryScores = [11]string{
	0:  "hate",
	1:  "hate/threatening",
	2:  "harassment",
	3:  "harassment/threatening",
	4:  "self-harm",
	5:  "self-harm/intent",
	6:  "self-harm/instructions",
	7:  "sexual",
	8:  "sexual/minors",
	9:  "violence",
	10: "violence/graphic",
}

// Decode decodes CreateModerationResponseResultsItemCategoryScores from json.
func (s *CreateModerationResponseResultsItemCategoryScores) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateModerationResponseResultsItemCategoryScores to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hate":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Hate = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hate\"")
			}
		case "hate/threatening":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.HateSlashThreatening = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hate/threatening\"")
			}
		case "harassment":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Harassment = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"harassment\"")
			}
		case "harassment/threatening":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.HarassmentSlashThreatening = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"harassment/threatening\"")
			}
		case "self-harm":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.SelfMinusHarm = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"self-harm\"")
			}
		case "self-harm/intent":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.SelfMinusHarmSlashIntent = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"self-harm/intent\"")
			}
		case "self-harm/instructions":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.SelfMinusHarmSlashInstructions = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"self-harm/instructions\"")
			}
		case "sexual":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Float64()
				s.Sexual = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sexual\"")
			}
		case "sexual/minors":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.SexualSlashMinors = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sexual/minors\"")
			}
		case "violence":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Violence = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"violence\"")
			}
		case "violence/graphic":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.ViolenceSlashGraphic = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"violence/graphic\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateModerationResponseResultsItemCategoryScores")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateModerationResponseResultsItemCategoryScores) {
					name = jsonFieldsNameOfCreateModerationResponseResultsItemCategoryScores[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateModerationResponseResultsItemCategoryScores) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateModerationResponseResultsItemCategoryScores) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateRunRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateRunRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("assistant_id")
		e.Str(s.AssistantID)
	}
	{
		if s.Model.Set {
			e.FieldStart("model")
			s.Model.Encode(e)
		}
	}
	{
		if s.Instructions.Set {
			e.FieldStart("instructions")
			s.Instructions.Encode(e)
		}
	}
	{
		if s.AdditionalInstructions.Set {
			e.FieldStart("additional_instructions")
			s.AdditionalInstructions.Encode(e)
		}
	}
	{
		if s.Tools.Set {
			e.FieldStart("tools")
			s.Tools.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateRunRequest = [6]string{
	0: "assistant_id",
	1: "model",
	2: "instructions",
	3: "additional_instructions",
	4: "tools",
	5: "metadata",
}

// Decode decodes CreateRunRequest from json.
func (s *CreateRunRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateRunRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assistant_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AssistantID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assistant_id\"")
			}
		case "model":
			if err := func() error {
				s.Model.Reset()
				if err := s.Model.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		case "instructions":
			if err := func() error {
				s.Instructions.Reset()
				if err := s.Instructions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instructions\"")
			}
		case "additional_instructions":
			if err := func() error {
				s.AdditionalInstructions.Reset()
				if err := s.AdditionalInstructions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additional_instructions\"")
			}
		case "tools":
			if err := func() error {
				s.Tools.Reset()
				if err := s.Tools.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tools\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateRunRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateRunRequest) {
					name = jsonFieldsNameOfCreateRunRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateRunRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateRunRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateRunRequestMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateRunRequestMetadata) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateRunRequestMetadata = [0]string{}

// Decode decodes CreateRunRequestMetadata from json.
func (s *CreateRunRequestMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateRunRequestMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CreateRunRequestMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateRunRequestMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateRunRequestMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateRunRequestToolsItem as json.
func (s CreateRunRequestToolsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s CreateRunRequestToolsItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case AssistantToolsCodeCreateRunRequestToolsItem:
		e.FieldStart("type")
		e.Str("code_interpreter")
		s.AssistantToolsCode.encodeFields(e)
	case AssistantToolsFunctionCreateRunRequestToolsItem:
		e.FieldStart("type")
		e.Str("function")
		s.AssistantToolsFunction.encodeFields(e)
	case AssistantToolsRetrievalCreateRunRequestToolsItem:
		e.FieldStart("type")
		e.Str("retrieval")
		s.AssistantToolsRetrieval.encodeFields(e)
	}
}

// Decode decodes CreateRunRequestToolsItem from json.
func (s *CreateRunRequestToolsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateRunRequestToolsItem to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "code_interpreter":
					s.Type = AssistantToolsCodeCreateRunRequestToolsItem
					found = true
				case "function":
					s.Type = AssistantToolsFunctionCreateRunRequestToolsItem
					found = true
				case "retrieval":
					s.Type = AssistantToolsRetrievalCreateRunRequestToolsItem
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case AssistantToolsCodeCreateRunRequestToolsItem:
		if err := s.AssistantToolsCode.Decode(d); err != nil {
			return err
		}
	case AssistantToolsRetrievalCreateRunRequestToolsItem:
		if err := s.AssistantToolsRetrieval.Decode(d); err != nil {
			return err
		}
	case AssistantToolsFunctionCreateRunRequestToolsItem:
		if err := s.AssistantToolsFunction.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateRunRequestToolsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateRunRequestToolsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateSpeechRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateSpeechRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("model")
		e.Str(s.Model)
	}
	{
		e.FieldStart("input")
		e.Str(s.Input)
	}
	{
		e.FieldStart("voice")
		s.Voice.Encode(e)
	}
	{
		if s.ResponseFormat.Set {
			e.FieldStart("response_format")
			s.ResponseFormat.Encode(e)
		}
	}
	{
		if s.Speed.Set {
			e.FieldStart("speed")
			s.Speed.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateSpeechRequest = [5]string{
	0: "model",
	1: "input",
	2: "voice",
	3: "response_format",
	4: "speed",
}

// Decode decodes CreateSpeechRequest from json.
func (s *CreateSpeechRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSpeechRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "model":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Model = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		case "input":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Input = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input\"")
			}
		case "voice":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Voice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice\"")
			}
		case "response_format":
			if err := func() error {
				s.ResponseFormat.Reset()
				if err := s.ResponseFormat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response_format\"")
			}
		case "speed":
			if err := func() error {
				s.Speed.Reset()
				if err := s.Speed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateSpeechRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateSpeechRequest) {
					name = jsonFieldsNameOfCreateSpeechRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSpeechRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSpeechRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateSpeechRequestResponseFormat as json.
func (s CreateSpeechRequestResponseFormat) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateSpeechRequestResponseFormat from json.
func (s *CreateSpeechRequestResponseFormat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSpeechRequestResponseFormat to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateSpeechRequestResponseFormat(v) {
	case CreateSpeechRequestResponseFormatMp3:
		*s = CreateSpeechRequestResponseFormatMp3
	case CreateSpeechRequestResponseFormatOpus:
		*s = CreateSpeechRequestResponseFormatOpus
	case CreateSpeechRequestResponseFormatAac:
		*s = CreateSpeechRequestResponseFormatAac
	case CreateSpeechRequestResponseFormatFlac:
		*s = CreateSpeechRequestResponseFormatFlac
	case CreateSpeechRequestResponseFormatWav:
		*s = CreateSpeechRequestResponseFormatWav
	case CreateSpeechRequestResponseFormatPcm:
		*s = CreateSpeechRequestResponseFormatPcm
	default:
		*s = CreateSpeechRequestResponseFormat(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateSpeechRequestResponseFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSpeechRequestResponseFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateSpeechRequestVoice as json.
func (s CreateSpeechRequestVoice) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateSpeechRequestVoice from json.
func (s *CreateSpeechRequestVoice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSpeechRequestVoice to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateSpeechRequestVoice(v) {
	case CreateSpeechRequestVoiceAlloy:
		*s = CreateSpeechRequestVoiceAlloy
	case CreateSpeechRequestVoiceEcho:
		*s = CreateSpeechRequestVoiceEcho
	case CreateSpeechRequestVoiceFable:
		*s = CreateSpeechRequestVoiceFable
	case CreateSpeechRequestVoiceOnyx:
		*s = CreateSpeechRequestVoiceOnyx
	case CreateSpeechRequestVoiceNova:
		*s = CreateSpeechRequestVoiceNova
	case CreateSpeechRequestVoiceShimmer:
		*s = CreateSpeechRequestVoiceShimmer
	default:
		*s = CreateSpeechRequestVoice(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateSpeechRequestVoice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSpeechRequestVoice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateThreadAndRunRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateThreadAndRunRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("assistant_id")
		e.Str(s.AssistantID)
	}
	{
		if s.Thread.Set {
			e.FieldStart("thread")
			s.Thread.Encode(e)
		}
	}
	{
		if s.Model.Set {
			e.FieldStart("model")
			s.Model.Encode(e)
		}
	}
	{
		if s.Instructions.Set {
			e.FieldStart("instructions")
			s.Instructions.Encode(e)
		}
	}
	{
		if s.Tools.Set {
			e.FieldStart("tools")
			s.Tools.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateThreadAndRunRequest = [6]string{
	0: "assistant_id",
	1: "thread",
	2: "model",
	3: "instructions",
	4: "tools",
	5: "metadata",
}

// Decode decodes CreateThreadAndRunRequest from json.
func (s *CreateThreadAndRunRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateThreadAndRunRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assistant_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AssistantID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assistant_id\"")
			}
		case "thread":
			if err := func() error {
				s.Thread.Reset()
				if err := s.Thread.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thread\"")
			}
		case "model":
			if err := func() error {
				s.Model.Reset()
				if err := s.Model.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		case "instructions":
			if err := func() error {
				s.Instructions.Reset()
				if err := s.Instructions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instructions\"")
			}
		case "tools":
			if err := func() error {
				s.Tools.Reset()
				if err := s.Tools.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tools\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateThreadAndRunRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateThreadAndRunRequest) {
					name = jsonFieldsNameOfCreateThreadAndRunRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateThreadAndRunRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateThreadAndRunRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateThreadAndRunRequestMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateThreadAndRunRequestMetadata) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateThreadAndRunRequestMetadata = [0]string{}

// Decode decodes CreateThreadAndRunRequestMetadata from json.
func (s *CreateThreadAndRunRequestMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateThreadAndRunRequestMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CreateThreadAndRunRequestMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateThreadAndRunRequestMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateThreadAndRunRequestMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateThreadAndRunRequestToolsItem as json.
func (s CreateThreadAndRunRequestToolsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s CreateThreadAndRunRequestToolsItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case AssistantToolsCodeCreateThreadAndRunRequestToolsItem:
		e.FieldStart("type")
		e.Str("code_interpreter")
		s.AssistantToolsCode.encodeFields(e)
	case AssistantToolsFunctionCreateThreadAndRunRequestToolsItem:
		e.FieldStart("type")
		e.Str("function")
		s.AssistantToolsFunction.encodeFields(e)
	case AssistantToolsRetrievalCreateThreadAndRunRequestToolsItem:
		e.FieldStart("type")
		e.Str("retrieval")
		s.AssistantToolsRetrieval.encodeFields(e)
	}
}

// Decode decodes CreateThreadAndRunRequestToolsItem from json.
func (s *CreateThreadAndRunRequestToolsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateThreadAndRunRequestToolsItem to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "code_interpreter":
					s.Type = AssistantToolsCodeCreateThreadAndRunRequestToolsItem
					found = true
				case "function":
					s.Type = AssistantToolsFunctionCreateThreadAndRunRequestToolsItem
					found = true
				case "retrieval":
					s.Type = AssistantToolsRetrievalCreateThreadAndRunRequestToolsItem
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case AssistantToolsCodeCreateThreadAndRunRequestToolsItem:
		if err := s.AssistantToolsCode.Decode(d); err != nil {
			return err
		}
	case AssistantToolsRetrievalCreateThreadAndRunRequestToolsItem:
		if err := s.AssistantToolsRetrieval.Decode(d); err != nil {
			return err
		}
	case AssistantToolsFunctionCreateThreadAndRunRequestToolsItem:
		if err := s.AssistantToolsFunction.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateThreadAndRunRequestToolsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateThreadAndRunRequestToolsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateThreadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateThreadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Messages != nil {
			e.FieldStart("messages")
			e.ArrStart()
			for _, elem := range s.Messages {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateThreadRequest = [2]string{
	0: "messages",
	1: "metadata",
}

// Decode decodes CreateThreadRequest from json.
func (s *CreateThreadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateThreadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "messages":
			if err := func() error {
				s.Messages = make([]CreateMessageRequest, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateMessageRequest
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Messages = append(s.Messages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"messages\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateThreadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateThreadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateThreadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateThreadRequestMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateThreadRequestMetadata) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateThreadRequestMetadata = [0]string{}

// Decode decodes CreateThreadRequestMetadata from json.
func (s *CreateThreadRequestMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateThreadRequestMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CreateThreadRequestMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateThreadRequestMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateThreadRequestMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTranscriptionOK as json.
func (s CreateTranscriptionOK) Encode(e *jx.Encoder) {
	switch s.Type {
	case CreateTranscriptionResponseJsonCreateTranscriptionOK:
		s.CreateTranscriptionResponseJson.Encode(e)
	case CreateTranscriptionResponseVerboseJsonCreateTranscriptionOK:
		s.CreateTranscriptionResponseVerboseJson.Encode(e)
	}
}

func (s CreateTranscriptionOK) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case CreateTranscriptionResponseJsonCreateTranscriptionOK:
		s.CreateTranscriptionResponseJson.encodeFields(e)
	case CreateTranscriptionResponseVerboseJsonCreateTranscriptionOK:
		s.CreateTranscriptionResponseVerboseJson.encodeFields(e)
	}
}

// Decode decodes CreateTranscriptionOK from json.
func (s *CreateTranscriptionOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTranscriptionOK to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "language":
				match := CreateTranscriptionResponseVerboseJsonCreateTranscriptionOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "duration":
				match := CreateTranscriptionResponseVerboseJsonCreateTranscriptionOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "words":
				match := CreateTranscriptionResponseVerboseJsonCreateTranscriptionOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "segments":
				match := CreateTranscriptionResponseVerboseJsonCreateTranscriptionOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		s.Type = CreateTranscriptionResponseJsonCreateTranscriptionOK
	}
	switch s.Type {
	case CreateTranscriptionResponseJsonCreateTranscriptionOK:
		if err := s.CreateTranscriptionResponseJson.Decode(d); err != nil {
			return err
		}
	case CreateTranscriptionResponseVerboseJsonCreateTranscriptionOK:
		if err := s.CreateTranscriptionResponseVerboseJson.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateTranscriptionOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTranscriptionOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateTranscriptionResponseJson) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateTranscriptionResponseJson) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
}

var jsonFieldsNameOfCreateTranscriptionResponseJson = [1]string{
	0: "text",
}

// Decode decodes CreateTranscriptionResponseJson from json.
func (s *CreateTranscriptionResponseJson) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTranscriptionResponseJson to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateTranscriptionResponseJson")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateTranscriptionResponseJson) {
					name = jsonFieldsNameOfCreateTranscriptionResponseJson[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTranscriptionResponseJson) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTranscriptionResponseJson) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateTranscriptionResponseVerboseJson) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateTranscriptionResponseVerboseJson) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("language")
		e.Str(s.Language)
	}
	{
		e.FieldStart("duration")
		e.Str(s.Duration)
	}
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		if s.Words != nil {
			e.FieldStart("words")
			e.ArrStart()
			for _, elem := range s.Words {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Segments != nil {
			e.FieldStart("segments")
			e.ArrStart()
			for _, elem := range s.Segments {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCreateTranscriptionResponseVerboseJson = [5]string{
	0: "language",
	1: "duration",
	2: "text",
	3: "words",
	4: "segments",
}

// Decode decodes CreateTranscriptionResponseVerboseJson from json.
func (s *CreateTranscriptionResponseVerboseJson) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTranscriptionResponseVerboseJson to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "language":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Language = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "duration":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Duration = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "text":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "words":
			if err := func() error {
				s.Words = make([]TranscriptionWord, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TranscriptionWord
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Words = append(s.Words, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"words\"")
			}
		case "segments":
			if err := func() error {
				s.Segments = make([]TranscriptionSegment, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TranscriptionSegment
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Segments = append(s.Segments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"segments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateTranscriptionResponseVerboseJson")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateTranscriptionResponseVerboseJson) {
					name = jsonFieldsNameOfCreateTranscriptionResponseVerboseJson[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTranscriptionResponseVerboseJson) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTranscriptionResponseVerboseJson) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTranslationOK as json.
func (s CreateTranslationOK) Encode(e *jx.Encoder) {
	switch s.Type {
	case CreateTranslationResponseJsonCreateTranslationOK:
		s.CreateTranslationResponseJson.Encode(e)
	case CreateTranslationResponseVerboseJsonCreateTranslationOK:
		s.CreateTranslationResponseVerboseJson.Encode(e)
	}
}

func (s CreateTranslationOK) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case CreateTranslationResponseJsonCreateTranslationOK:
		s.CreateTranslationResponseJson.encodeFields(e)
	case CreateTranslationResponseVerboseJsonCreateTranslationOK:
		s.CreateTranslationResponseVerboseJson.encodeFields(e)
	}
}

// Decode decodes CreateTranslationOK from json.
func (s *CreateTranslationOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTranslationOK to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "language":
				match := CreateTranslationResponseVerboseJsonCreateTranslationOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "duration":
				match := CreateTranslationResponseVerboseJsonCreateTranslationOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "segments":
				match := CreateTranslationResponseVerboseJsonCreateTranslationOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		s.Type = CreateTranslationResponseJsonCreateTranslationOK
	}
	switch s.Type {
	case CreateTranslationResponseJsonCreateTranslationOK:
		if err := s.CreateTranslationResponseJson.Decode(d); err != nil {
			return err
		}
	case CreateTranslationResponseVerboseJsonCreateTranslationOK:
		if err := s.CreateTranslationResponseVerboseJson.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateTranslationOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTranslationOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateTranslationResponseJson) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateTranslationResponseJson) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
}

var jsonFieldsNameOfCreateTranslationResponseJson = [1]string{
	0: "text",
}

// Decode decodes CreateTranslationResponseJson from json.
func (s *CreateTranslationResponseJson) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTranslationResponseJson to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateTranslationResponseJson")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateTranslationResponseJson) {
					name = jsonFieldsNameOfCreateTranslationResponseJson[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTranslationResponseJson) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTranslationResponseJson) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateTranslationResponseVerboseJson) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateTranslationResponseVerboseJson) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("language")
		e.Str(s.Language)
	}
	{
		e.FieldStart("duration")
		e.Str(s.Duration)
	}
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		if s.Segments != nil {
			e.FieldStart("segments")
			e.ArrStart()
			for _, elem := range s.Segments {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCreateTranslationResponseVerboseJson = [4]string{
	0: "language",
	1: "duration",
	2: "text",
	3: "segments",
}

// Decode decodes CreateTranslationResponseVerboseJson from json.
func (s *CreateTranslationResponseVerboseJson) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTranslationResponseVerboseJson to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "language":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Language = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "duration":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Duration = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "text":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "segments":
			if err := func() error {
				s.Segments = make([]TranscriptionSegment, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TranscriptionSegment
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Segments = append(s.Segments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"segments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateTranslationResponseVerboseJson")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateTranslationResponseVerboseJson) {
					name = jsonFieldsNameOfCreateTranslationResponseVerboseJson[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTranslationResponseVerboseJson) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTranslationResponseVerboseJson) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteAssistantFileResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteAssistantFileResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("deleted")
		e.Bool(s.Deleted)
	}
	{
		e.FieldStart("object")
		s.Object.Encode(e)
	}
}

var jsonFieldsNameOfDeleteAssistantFileResponse = [3]string{
	0: "id",
	1: "deleted",
	2: "object",
}

// Decode decodes DeleteAssistantFileResponse from json.
func (s *DeleteAssistantFileResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteAssistantFileResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "deleted":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Deleted = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deleted\"")
			}
		case "object":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteAssistantFileResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteAssistantFileResponse) {
					name = jsonFieldsNameOfDeleteAssistantFileResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteAssistantFileResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteAssistantFileResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteAssistantFileResponseObject as json.
func (s DeleteAssistantFileResponseObject) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DeleteAssistantFileResponseObject from json.
func (s *DeleteAssistantFileResponseObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteAssistantFileResponseObject to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DeleteAssistantFileResponseObject(v) {
	case DeleteAssistantFileResponseObjectAssistantFileDeleted:
		*s = DeleteAssistantFileResponseObjectAssistantFileDeleted
	default:
		*s = DeleteAssistantFileResponseObject(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeleteAssistantFileResponseObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteAssistantFileResponseObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteAssistantResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteAssistantResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("deleted")
		e.Bool(s.Deleted)
	}
	{
		e.FieldStart("object")
		s.Object.Encode(e)
	}
}

var jsonFieldsNameOfDeleteAssistantResponse = [3]string{
	0: "id",
	1: "deleted",
	2: "object",
}

// Decode decodes DeleteAssistantResponse from json.
func (s *DeleteAssistantResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteAssistantResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "deleted":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Deleted = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deleted\"")
			}
		case "object":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteAssistantResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteAssistantResponse) {
					name = jsonFieldsNameOfDeleteAssistantResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteAssistantResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteAssistantResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteAssistantResponseObject as json.
func (s DeleteAssistantResponseObject) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DeleteAssistantResponseObject from json.
func (s *DeleteAssistantResponseObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteAssistantResponseObject to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DeleteAssistantResponseObject(v) {
	case DeleteAssistantResponseObjectAssistantDeleted:
		*s = DeleteAssistantResponseObjectAssistantDeleted
	default:
		*s = DeleteAssistantResponseObject(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeleteAssistantResponseObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteAssistantResponseObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteFileResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteFileResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("object")
		s.Object.Encode(e)
	}
	{
		e.FieldStart("deleted")
		e.Bool(s.Deleted)
	}
}

var jsonFieldsNameOfDeleteFileResponse = [3]string{
	0: "id",
	1: "object",
	2: "deleted",
}

// Decode decodes DeleteFileResponse from json.
func (s *DeleteFileResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteFileResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "object":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "deleted":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Deleted = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deleted\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteFileResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteFileResponse) {
					name = jsonFieldsNameOfDeleteFileResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteFileResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteFileResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteFileResponseObject as json.
func (s DeleteFileResponseObject) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DeleteFileResponseObject from json.
func (s *DeleteFileResponseObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteFileResponseObject to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DeleteFileResponseObject(v) {
	case DeleteFileResponseObjectFile:
		*s = DeleteFileResponseObjectFile
	default:
		*s = DeleteFileResponseObject(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeleteFileResponseObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteFileResponseObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteModelResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteModelResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("deleted")
		e.Bool(s.Deleted)
	}
	{
		e.FieldStart("object")
		e.Str(s.Object)
	}
}

var jsonFieldsNameOfDeleteModelResponse = [3]string{
	0: "id",
	1: "deleted",
	2: "object",
}

// Decode decodes DeleteModelResponse from json.
func (s *DeleteModelResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteModelResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "deleted":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Deleted = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deleted\"")
			}
		case "object":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Object = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteModelResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteModelResponse) {
					name = jsonFieldsNameOfDeleteModelResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteModelResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteModelResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteThreadResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteThreadResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("deleted")
		e.Bool(s.Deleted)
	}
	{
		e.FieldStart("object")
		s.Object.Encode(e)
	}
}

var jsonFieldsNameOfDeleteThreadResponse = [3]string{
	0: "id",
	1: "deleted",
	2: "object",
}

// Decode decodes DeleteThreadResponse from json.
func (s *DeleteThreadResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteThreadResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "deleted":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Deleted = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deleted\"")
			}
		case "object":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteThreadResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteThreadResponse) {
					name = jsonFieldsNameOfDeleteThreadResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteThreadResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteThreadResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteThreadResponseObject as json.
func (s DeleteThreadResponseObject) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DeleteThreadResponseObject from json.
func (s *DeleteThreadResponseObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteThreadResponseObject to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DeleteThreadResponseObject(v) {
	case DeleteThreadResponseObjectThreadDeleted:
		*s = DeleteThreadResponseObjectThreadDeleted
	default:
		*s = DeleteThreadResponseObject(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeleteThreadResponseObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteThreadResponseObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Error) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Error) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		s.Code.Encode(e)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		e.FieldStart("param")
		s.Param.Encode(e)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfError = [4]string{
	0: "code",
	1: "message",
	2: "param",
	3: "type",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "param":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Param.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"param\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Error")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfError) {
					name = jsonFieldsNameOfError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("error")
		s.Error.Encode(e)
	}
}

var jsonFieldsNameOfErrorResponse = [1]string{
	0: "error",
}

// Decode decodes ErrorResponse from json.
func (s *ErrorResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfErrorResponse) {
					name = jsonFieldsNameOfErrorResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FineTuningJob) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FineTuningJob) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("created_at")
		e.Int(s.CreatedAt)
	}
	{
		e.FieldStart("error")
		s.Error.Encode(e)
	}
	{
		e.FieldStart("fine_tuned_model")
		s.FineTunedModel.Encode(e)
	}
	{
		e.FieldStart("finished_at")
		s.FinishedAt.Encode(e)
	}
	{
		e.FieldStart("hyperparameters")
		s.Hyperparameters.Encode(e)
	}
	{
		e.FieldStart("model")
		e.Str(s.Model)
	}
	{
		e.FieldStart("object")
		s.Object.Encode(e)
	}
	{
		e.FieldStart("organization_id")
		e.Str(s.OrganizationID)
	}
	{
		e.FieldStart("result_files")
		e.ArrStart()
		for _, elem := range s.ResultFiles {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("trained_tokens")
		s.TrainedTokens.Encode(e)
	}
	{
		e.FieldStart("training_file")
		e.Str(s.TrainingFile)
	}
	{
		e.FieldStart("validation_file")
		s.ValidationFile.Encode(e)
	}
}

var jsonFieldsNameOfFineTuningJob = [14]string{
	0:  "id",
	1:  "created_at",
	2:  "error",
	3:  "fine_tuned_model",
	4:  "finished_at",
	5:  "hyperparameters",
	6:  "model",
	7:  "object",
	8:  "organization_id",
	9:  "result_files",
	10: "status",
	11: "trained_tokens",
	12: "training_file",
	13: "validation_file",
}

// Decode decodes FineTuningJob from json.
func (s *FineTuningJob) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FineTuningJob to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.CreatedAt = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "error":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "fine_tuned_model":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.FineTunedModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fine_tuned_model\"")
			}
		case "finished_at":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.FinishedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finished_at\"")
			}
		case "hyperparameters":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Hyperparameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hyperparameters\"")
			}
		case "model":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Model = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		case "object":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "organization_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.OrganizationID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_id\"")
			}
		case "result_files":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				s.ResultFiles = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ResultFiles = append(s.ResultFiles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result_files\"")
			}
		case "status":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "trained_tokens":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.TrainedTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trained_tokens\"")
			}
		case "training_file":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.TrainingFile = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"training_file\"")
			}
		case "validation_file":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.ValidationFile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validation_file\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FineTuningJob")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFineTuningJob) {
					name = jsonFieldsNameOfFineTuningJob[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FineTuningJob) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FineTuningJob) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FineTuningJobError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FineTuningJobError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		e.FieldStart("param")
		s.Param.Encode(e)
	}
}

var jsonFieldsNameOfFineTuningJobError = [3]string{
	0: "code",
	1: "message",
	2: "param",
}

// Decode decodes FineTuningJobError from json.
func (s *FineTuningJobError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FineTuningJobError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "param":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Param.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"param\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FineTuningJobError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFineTuningJobError) {
					name = jsonFieldsNameOfFineTuningJobError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FineTuningJobError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FineTuningJobError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FineTuningJobEvent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FineTuningJobEvent) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("created_at")
		e.Int(s.CreatedAt)
	}
	{
		e.FieldStart("level")
		s.Level.Encode(e)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		e.FieldStart("object")
		s.Object.Encode(e)
	}
}

var jsonFieldsNameOfFineTuningJobEvent = [5]string{
	0: "id",
	1: "created_at",
	2: "level",
	3: "message",
	4: "object",
}

// Decode decodes FineTuningJobEvent from json.
func (s *FineTuningJobEvent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FineTuningJobEvent to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.CreatedAt = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Level.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "object":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FineTuningJobEvent")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFineTuningJobEvent) {
					name = jsonFieldsNameOfFineTuningJobEvent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FineTuningJobEvent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FineTuningJobEvent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FineTuningJobEventLevel as json.
func (s FineTuningJobEventLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FineTuningJobEventLevel from json.
func (s *FineTuningJobEventLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FineTuningJobEventLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FineTuningJobEventLevel(v) {
	case FineTuningJobEventLevelInfo:
		*s = FineTuningJobEventLevelInfo
	case FineTuningJobEventLevelWarn:
		*s = FineTuningJobEventLevelWarn
	case FineTuningJobEventLevelError:
		*s = FineTuningJobEventLevelError
	default:
		*s = FineTuningJobEventLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FineTuningJobEventLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FineTuningJobEventLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FineTuningJobEventObject as json.
func (s FineTuningJobEventObject) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FineTuningJobEventObject from json.
func (s *FineTuningJobEventObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FineTuningJobEventObject to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FineTuningJobEventObject(v) {
	case FineTuningJobEventObjectFineTuningJobEvent:
		*s = FineTuningJobEventObjectFineTuningJobEvent
	default:
		*s = FineTuningJobEventObject(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FineTuningJobEventObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FineTuningJobEventObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FineTuningJobHyperparameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FineTuningJobHyperparameters) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("n_epochs")
		s.NEpochs.Encode(e)
	}
}

var jsonFieldsNameOfFineTuningJobHyperparameters = [1]string{
	0: "n_epochs",
}

// Decode decodes FineTuningJobHyperparameters from json.
func (s *FineTuningJobHyperparameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FineTuningJobHyperparameters to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "n_epochs":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.NEpochs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"n_epochs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FineTuningJobHyperparameters")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFineTuningJobHyperparameters) {
					name = jsonFieldsNameOfFineTuningJobHyperparameters[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FineTuningJobHyperparameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FineTuningJobHyperparameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FineTuningJobHyperparametersNEpochs as json.
func (s FineTuningJobHyperparametersNEpochs) Encode(e *jx.Encoder) {
	switch s.Type {
	case FineTuningJobHyperparametersNEpochs0FineTuningJobHyperparametersNEpochs:
		s.FineTuningJobHyperparametersNEpochs0.Encode(e)
	case IntFineTuningJobHyperparametersNEpochs:
		e.Int(s.Int)
	}
}

// Decode decodes FineTuningJobHyperparametersNEpochs from json.
func (s *FineTuningJobHyperparametersNEpochs) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FineTuningJobHyperparametersNEpochs to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntFineTuningJobHyperparametersNEpochs
	case jx.String:
		if err := s.FineTuningJobHyperparametersNEpochs0.Decode(d); err != nil {
			return err
		}
		s.Type = FineTuningJobHyperparametersNEpochs0FineTuningJobHyperparametersNEpochs
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FineTuningJobHyperparametersNEpochs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FineTuningJobHyperparametersNEpochs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FineTuningJobHyperparametersNEpochs0 as json.
func (s FineTuningJobHyperparametersNEpochs0) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FineTuningJobHyperparametersNEpochs0 from json.
func (s *FineTuningJobHyperparametersNEpochs0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FineTuningJobHyperparametersNEpochs0 to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FineTuningJobHyperparametersNEpochs0(v) {
	case FineTuningJobHyperparametersNEpochs0Auto:
		*s = FineTuningJobHyperparametersNEpochs0Auto
	default:
		*s = FineTuningJobHyperparametersNEpochs0(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FineTuningJobHyperparametersNEpochs0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FineTuningJobHyperparametersNEpochs0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FineTuningJobObject as json.
func (s FineTuningJobObject) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FineTuningJobObject from json.
func (s *FineTuningJobObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FineTuningJobObject to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FineTuningJobObject(v) {
	case FineTuningJobObjectFineTuningJob:
		*s = FineTuningJobObjectFineTuningJob
	default:
		*s = FineTuningJobObject(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FineTuningJobObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FineTuningJobObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FineTuningJobStatus as json.
func (s FineTuningJobStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FineTuningJobStatus from json.
func (s *FineTuningJobStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FineTuningJobStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FineTuningJobStatus(v) {
	case FineTuningJobStatusValidatingFiles:
		*s = FineTuningJobStatusValidatingFiles
	case FineTuningJobStatusQueued:
		*s = FineTuningJobStatusQueued
	case FineTuningJobStatusRunning:
		*s = FineTuningJobStatusRunning
	case FineTuningJobStatusSucceeded:
		*s = FineTuningJobStatusSucceeded
	case FineTuningJobStatusFailed:
		*s = FineTuningJobStatusFailed
	case FineTuningJobStatusCancelled:
		*s = FineTuningJobStatusCancelled
	default:
		*s = FineTuningJobStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FineTuningJobStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FineTuningJobStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FunctionObject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FunctionObject) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Parameters.Set {
			e.FieldStart("parameters")
			s.Parameters.Encode(e)
		}
	}
}

var jsonFieldsNameOfFunctionObject = [3]string{
	0: "description",
	1: "name",
	2: "parameters",
}

// Decode decodes FunctionObject from json.
func (s *FunctionObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FunctionObject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters.Reset()
				if err := s.Parameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FunctionObject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFunctionObject) {
					name = jsonFieldsNameOfFunctionObject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FunctionObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FunctionObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s FunctionParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s FunctionParameters) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes FunctionParameters from json.
func (s *FunctionParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FunctionParameters to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FunctionParameters")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FunctionParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FunctionParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Image) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Image) encodeFields(e *jx.Encoder) {
	{
		if s.B64JSON.Set {
			e.FieldStart("b64_json")
			s.B64JSON.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.RevisedPrompt.Set {
			e.FieldStart("revised_prompt")
			s.RevisedPrompt.Encode(e)
		}
	}
}

var jsonFieldsNameOfImage = [3]string{
	0: "b64_json",
	1: "url",
	2: "revised_prompt",
}

// Decode decodes Image from json.
func (s *Image) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Image to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "b64_json":
			if err := func() error {
				s.B64JSON.Reset()
				if err := s.B64JSON.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"b64_json\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "revised_prompt":
			if err := func() error {
				s.RevisedPrompt.Reset()
				if err := s.RevisedPrompt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"revised_prompt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Image")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Image) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Image) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ImagesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ImagesResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("created")
		e.Int(s.Created)
	}
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfImagesResponse = [2]string{
	0: "created",
	1: "data",
}

// Decode decodes ImagesResponse from json.
func (s *ImagesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ImagesResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "created":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Created = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created\"")
			}
		case "data":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Data = make([]Image, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Image
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ImagesResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfImagesResponse) {
					name = jsonFieldsNameOfImagesResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ImagesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ImagesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListAssistantFilesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListAssistantFilesResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("object")
		e.Str(s.Object)
	}
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("first_id")
		e.Str(s.FirstID)
	}
	{
		e.FieldStart("last_id")
		e.Str(s.LastID)
	}
	{
		e.FieldStart("has_more")
		e.Bool(s.HasMore)
	}
}

var jsonFieldsNameOfListAssistantFilesResponse = [5]string{
	0: "object",
	1: "data",
	2: "first_id",
	3: "last_id",
	4: "has_more",
}

// Decode decodes ListAssistantFilesResponse from json.
func (s *ListAssistantFilesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListAssistantFilesResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Object = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "data":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Data = make([]AssistantFileObject, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AssistantFileObject
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "first_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.FirstID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_id\"")
			}
		case "last_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.LastID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_id\"")
			}
		case "has_more":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_more\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListAssistantFilesResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListAssistantFilesResponse) {
					name = jsonFieldsNameOfListAssistantFilesResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListAssistantFilesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListAssistantFilesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListAssistantsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListAssistantsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("object")
		e.Str(s.Object)
	}
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("first_id")
		e.Str(s.FirstID)
	}
	{
		e.FieldStart("last_id")
		e.Str(s.LastID)
	}
	{
		e.FieldStart("has_more")
		e.Bool(s.HasMore)
	}
}

var jsonFieldsNameOfListAssistantsResponse = [5]string{
	0: "object",
	1: "data",
	2: "first_id",
	3: "last_id",
	4: "has_more",
}

// Decode decodes ListAssistantsResponse from json.
func (s *ListAssistantsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListAssistantsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Object = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "data":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Data = make([]AssistantObject, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AssistantObject
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "first_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.FirstID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_id\"")
			}
		case "last_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.LastID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_id\"")
			}
		case "has_more":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_more\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListAssistantsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListAssistantsResponse) {
					name = jsonFieldsNameOfListAssistantsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListAssistantsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListAssistantsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListFilesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListFilesResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("object")
		s.Object.Encode(e)
	}
}

var jsonFieldsNameOfListFilesResponse = [2]string{
	0: "data",
	1: "object",
}

// Decode decodes ListFilesResponse from json.
func (s *ListFilesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListFilesResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]OpenAIFile, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem OpenAIFile
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "object":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListFilesResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListFilesResponse) {
					name = jsonFieldsNameOfListFilesResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListFilesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListFilesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListFilesResponseObject as json.
func (s ListFilesResponseObject) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ListFilesResponseObject from json.
func (s *ListFilesResponseObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListFilesResponseObject to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ListFilesResponseObject(v) {
	case ListFilesResponseObjectList:
		*s = ListFilesResponseObjectList
	default:
		*s = ListFilesResponseObject(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListFilesResponseObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListFilesResponseObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListFineTuningJobEventsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListFineTuningJobEventsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("object")
		s.Object.Encode(e)
	}
}

var jsonFieldsNameOfListFineTuningJobEventsResponse = [2]string{
	0: "data",
	1: "object",
}

// Decode decodes ListFineTuningJobEventsResponse from json.
func (s *ListFineTuningJobEventsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListFineTuningJobEventsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]FineTuningJobEvent, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FineTuningJobEvent
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "object":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListFineTuningJobEventsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListFineTuningJobEventsResponse) {
					name = jsonFieldsNameOfListFineTuningJobEventsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListFineTuningJobEventsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListFineTuningJobEventsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListFineTuningJobEventsResponseObject as json.
func (s ListFineTuningJobEventsResponseObject) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ListFineTuningJobEventsResponseObject from json.
func (s *ListFineTuningJobEventsResponseObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListFineTuningJobEventsResponseObject to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ListFineTuningJobEventsResponseObject(v) {
	case ListFineTuningJobEventsResponseObjectList:
		*s = ListFineTuningJobEventsResponseObjectList
	default:
		*s = ListFineTuningJobEventsResponseObject(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListFineTuningJobEventsResponseObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListFineTuningJobEventsResponseObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListMessageFilesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListMessageFilesResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("object")
		e.Str(s.Object)
	}
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("first_id")
		e.Str(s.FirstID)
	}
	{
		e.FieldStart("last_id")
		e.Str(s.LastID)
	}
	{
		e.FieldStart("has_more")
		e.Bool(s.HasMore)
	}
}

var jsonFieldsNameOfListMessageFilesResponse = [5]string{
	0: "object",
	1: "data",
	2: "first_id",
	3: "last_id",
	4: "has_more",
}

// Decode decodes ListMessageFilesResponse from json.
func (s *ListMessageFilesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListMessageFilesResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Object = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "data":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Data = make([]MessageFileObject, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageFileObject
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "first_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.FirstID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_id\"")
			}
		case "last_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.LastID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_id\"")
			}
		case "has_more":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_more\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListMessageFilesResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListMessageFilesResponse) {
					name = jsonFieldsNameOfListMessageFilesResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListMessageFilesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListMessageFilesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListMessagesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListMessagesResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("object")
		e.Str(s.Object)
	}
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("first_id")
		e.Str(s.FirstID)
	}
	{
		e.FieldStart("last_id")
		e.Str(s.LastID)
	}
	{
		e.FieldStart("has_more")
		e.Bool(s.HasMore)
	}
}

var jsonFieldsNameOfListMessagesResponse = [5]string{
	0: "object",
	1: "data",
	2: "first_id",
	3: "last_id",
	4: "has_more",
}

// Decode decodes ListMessagesResponse from json.
func (s *ListMessagesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListMessagesResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Object = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "data":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Data = make([]MessageObject, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageObject
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "first_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.FirstID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_id\"")
			}
		case "last_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.LastID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_id\"")
			}
		case "has_more":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_more\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListMessagesResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListMessagesResponse) {
					name = jsonFieldsNameOfListMessagesResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListMessagesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListMessagesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListModelsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListModelsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("object")
		s.Object.Encode(e)
	}
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfListModelsResponse = [2]string{
	0: "object",
	1: "data",
}

// Decode decodes ListModelsResponse from json.
func (s *ListModelsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListModelsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "data":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Data = make([]Model, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Model
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListModelsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListModelsResponse) {
					name = jsonFieldsNameOfListModelsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListModelsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListModelsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListModelsResponseObject as json.
func (s ListModelsResponseObject) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ListModelsResponseObject from json.
func (s *ListModelsResponseObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListModelsResponseObject to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ListModelsResponseObject(v) {
	case ListModelsResponseObjectList:
		*s = ListModelsResponseObjectList
	default:
		*s = ListModelsResponseObject(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListModelsResponseObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListModelsResponseObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListPaginatedFineTuningJobsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListPaginatedFineTuningJobsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("has_more")
		e.Bool(s.HasMore)
	}
	{
		e.FieldStart("object")
		s.Object.Encode(e)
	}
}

var jsonFieldsNameOfListPaginatedFineTuningJobsResponse = [3]string{
	0: "data",
	1: "has_more",
	2: "object",
}

// Decode decodes ListPaginatedFineTuningJobsResponse from json.
func (s *ListPaginatedFineTuningJobsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListPaginatedFineTuningJobsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]FineTuningJob, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FineTuningJob
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "has_more":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_more\"")
			}
		case "object":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListPaginatedFineTuningJobsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListPaginatedFineTuningJobsResponse) {
					name = jsonFieldsNameOfListPaginatedFineTuningJobsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListPaginatedFineTuningJobsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListPaginatedFineTuningJobsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListPaginatedFineTuningJobsResponseObject as json.
func (s ListPaginatedFineTuningJobsResponseObject) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ListPaginatedFineTuningJobsResponseObject from json.
func (s *ListPaginatedFineTuningJobsResponseObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListPaginatedFineTuningJobsResponseObject to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ListPaginatedFineTuningJobsResponseObject(v) {
	case ListPaginatedFineTuningJobsResponseObjectList:
		*s = ListPaginatedFineTuningJobsResponseObjectList
	default:
		*s = ListPaginatedFineTuningJobsResponseObject(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListPaginatedFineTuningJobsResponseObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListPaginatedFineTuningJobsResponseObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListRunStepsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListRunStepsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("object")
		e.Str(s.Object)
	}
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("first_id")
		e.Str(s.FirstID)
	}
	{
		e.FieldStart("last_id")
		e.Str(s.LastID)
	}
	{
		e.FieldStart("has_more")
		e.Bool(s.HasMore)
	}
}

var jsonFieldsNameOfListRunStepsResponse = [5]string{
	0: "object",
	1: "data",
	2: "first_id",
	3: "last_id",
	4: "has_more",
}

// Decode decodes ListRunStepsResponse from json.
func (s *ListRunStepsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListRunStepsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Object = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "data":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Data = make([]RunStepObject, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RunStepObject
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "first_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.FirstID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_id\"")
			}
		case "last_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.LastID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_id\"")
			}
		case "has_more":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_more\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListRunStepsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListRunStepsResponse) {
					name = jsonFieldsNameOfListRunStepsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListRunStepsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListRunStepsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListRunsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListRunsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("object")
		e.Str(s.Object)
	}
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("first_id")
		e.Str(s.FirstID)
	}
	{
		e.FieldStart("last_id")
		e.Str(s.LastID)
	}
	{
		e.FieldStart("has_more")
		e.Bool(s.HasMore)
	}
}

var jsonFieldsNameOfListRunsResponse = [5]string{
	0: "object",
	1: "data",
	2: "first_id",
	3: "last_id",
	4: "has_more",
}

// Decode decodes ListRunsResponse from json.
func (s *ListRunsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListRunsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Object = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "data":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Data = make([]RunObject, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RunObject
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "first_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.FirstID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_id\"")
			}
		case "last_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.LastID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_id\"")
			}
		case "has_more":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_more\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListRunsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListRunsResponse) {
					name = jsonFieldsNameOfListRunsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListRunsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListRunsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MessageContentImageFileObject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MessageContentImageFileObject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("image_file")
		s.ImageFile.Encode(e)
	}
}

var jsonFieldsNameOfMessageContentImageFileObject = [2]string{
	0: "type",
	1: "image_file",
}

// Decode decodes MessageContentImageFileObject from json.
func (s *MessageContentImageFileObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageContentImageFileObject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "image_file":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ImageFile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image_file\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MessageContentImageFileObject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMessageContentImageFileObject) {
					name = jsonFieldsNameOfMessageContentImageFileObject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MessageContentImageFileObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageContentImageFileObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MessageContentImageFileObjectImageFile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MessageContentImageFileObjectImageFile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("file_id")
		e.Str(s.FileID)
	}
}

var jsonFieldsNameOfMessageContentImageFileObjectImageFile = [1]string{
	0: "file_id",
}

// Decode decodes MessageContentImageFileObjectImageFile from json.
func (s *MessageContentImageFileObjectImageFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageContentImageFileObjectImageFile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MessageContentImageFileObjectImageFile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMessageContentImageFileObjectImageFile) {
					name = jsonFieldsNameOfMessageContentImageFileObjectImageFile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MessageContentImageFileObjectImageFile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageContentImageFileObjectImageFile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MessageContentImageFileObjectType as json.
func (s MessageContentImageFileObjectType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MessageContentImageFileObjectType from json.
func (s *MessageContentImageFileObjectType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageContentImageFileObjectType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MessageContentImageFileObjectType(v) {
	case MessageContentImageFileObjectTypeImageFile:
		*s = MessageContentImageFileObjectTypeImageFile
	default:
		*s = MessageContentImageFileObjectType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MessageContentImageFileObjectType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageContentImageFileObjectType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MessageContentTextAnnotationsFileCitationObject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MessageContentTextAnnotationsFileCitationObject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		e.FieldStart("file_citation")
		s.FileCitation.Encode(e)
	}
	{
		e.FieldStart("start_index")
		e.Int(s.StartIndex)
	}
	{
		e.FieldStart("end_index")
		e.Int(s.EndIndex)
	}
}

var jsonFieldsNameOfMessageContentTextAnnotationsFileCitationObject = [5]string{
	0: "type",
	1: "text",
	2: "file_citation",
	3: "start_index",
	4: "end_index",
}

// Decode decodes MessageContentTextAnnotationsFileCitationObject from json.
func (s *MessageContentTextAnnotationsFileCitationObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageContentTextAnnotationsFileCitationObject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "text":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "file_citation":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FileCitation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_citation\"")
			}
		case "start_index":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.StartIndex = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_index\"")
			}
		case "end_index":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.EndIndex = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_index\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MessageContentTextAnnotationsFileCitationObject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMessageContentTextAnnotationsFileCitationObject) {
					name = jsonFieldsNameOfMessageContentTextAnnotationsFileCitationObject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MessageContentTextAnnotationsFileCitationObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageContentTextAnnotationsFileCitationObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MessageContentTextAnnotationsFileCitationObjectFileCitation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MessageContentTextAnnotationsFileCitationObjectFileCitation) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("file_id")
		e.Str(s.FileID)
	}
	{
		e.FieldStart("quote")
		e.Str(s.Quote)
	}
}

var jsonFieldsNameOfMessageContentTextAnnotationsFileCitationObjectFileCitation = [2]string{
	0: "file_id",
	1: "quote",
}

// Decode decodes MessageContentTextAnnotationsFileCitationObjectFileCitation from json.
func (s *MessageContentTextAnnotationsFileCitationObjectFileCitation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageContentTextAnnotationsFileCitationObjectFileCitation to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_id\"")
			}
		case "quote":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Quote = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quote\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MessageContentTextAnnotationsFileCitationObjectFileCitation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMessageContentTextAnnotationsFileCitationObjectFileCitation) {
					name = jsonFieldsNameOfMessageContentTextAnnotationsFileCitationObjectFileCitation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MessageContentTextAnnotationsFileCitationObjectFileCitation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageContentTextAnnotationsFileCitationObjectFileCitation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MessageContentTextAnnotationsFileCitationObjectType as json.
func (s MessageContentTextAnnotationsFileCitationObjectType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MessageContentTextAnnotationsFileCitationObjectType from json.
func (s *MessageContentTextAnnotationsFileCitationObjectType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageContentTextAnnotationsFileCitationObjectType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MessageContentTextAnnotationsFileCitationObjectType(v) {
	case MessageContentTextAnnotationsFileCitationObjectTypeFileCitation:
		*s = MessageContentTextAnnotationsFileCitationObjectTypeFileCitation
	default:
		*s = MessageContentTextAnnotationsFileCitationObjectType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MessageContentTextAnnotationsFileCitationObjectType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageContentTextAnnotationsFileCitationObjectType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MessageContentTextAnnotationsFilePathObject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MessageContentTextAnnotationsFilePathObject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		e.FieldStart("file_path")
		s.FilePath.Encode(e)
	}
	{
		e.FieldStart("start_index")
		e.Int(s.StartIndex)
	}
	{
		e.FieldStart("end_index")
		e.Int(s.EndIndex)
	}
}

var jsonFieldsNameOfMessageContentTextAnnotationsFilePathObject = [5]string{
	0: "type",
	1: "text",
	2: "file_path",
	3: "start_index",
	4: "end_index",
}

// Decode decodes MessageContentTextAnnotationsFilePathObject from json.
func (s *MessageContentTextAnnotationsFilePathObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageContentTextAnnotationsFilePathObject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "text":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "file_path":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FilePath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_path\"")
			}
		case "start_index":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.StartIndex = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_index\"")
			}
		case "end_index":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.EndIndex = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_index\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MessageContentTextAnnotationsFilePathObject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMessageContentTextAnnotationsFilePathObject) {
					name = jsonFieldsNameOfMessageContentTextAnnotationsFilePathObject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MessageContentTextAnnotationsFilePathObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageContentTextAnnotationsFilePathObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MessageContentTextAnnotationsFilePathObjectFilePath) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MessageContentTextAnnotationsFilePathObjectFilePath) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("file_id")
		e.Str(s.FileID)
	}
}

var jsonFieldsNameOfMessageContentTextAnnotationsFilePathObjectFilePath = [1]string{
	0: "file_id",
}

// Decode decodes MessageContentTextAnnotationsFilePathObjectFilePath from json.
func (s *MessageContentTextAnnotationsFilePathObjectFilePath) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageContentTextAnnotationsFilePathObjectFilePath to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MessageContentTextAnnotationsFilePathObjectFilePath")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMessageContentTextAnnotationsFilePathObjectFilePath) {
					name = jsonFieldsNameOfMessageContentTextAnnotationsFilePathObjectFilePath[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MessageContentTextAnnotationsFilePathObjectFilePath) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageContentTextAnnotationsFilePathObjectFilePath) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MessageContentTextAnnotationsFilePathObjectType as json.
func (s MessageContentTextAnnotationsFilePathObjectType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MessageContentTextAnnotationsFilePathObjectType from json.
func (s *MessageContentTextAnnotationsFilePathObjectType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageContentTextAnnotationsFilePathObjectType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MessageContentTextAnnotationsFilePathObjectType(v) {
	case MessageContentTextAnnotationsFilePathObjectTypeFilePath:
		*s = MessageContentTextAnnotationsFilePathObjectTypeFilePath
	default:
		*s = MessageContentTextAnnotationsFilePathObjectType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MessageContentTextAnnotationsFilePathObjectType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageContentTextAnnotationsFilePathObjectType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MessageContentTextObject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MessageContentTextObject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("text")
		s.Text.Encode(e)
	}
}

var jsonFieldsNameOfMessageContentTextObject = [2]string{
	0: "type",
	1: "text",
}

// Decode decodes MessageContentTextObject from json.
func (s *MessageContentTextObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageContentTextObject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "text":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MessageContentTextObject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMessageContentTextObject) {
					name = jsonFieldsNameOfMessageContentTextObject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MessageContentTextObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageContentTextObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MessageContentTextObjectText) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MessageContentTextObjectText) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
	{
		e.FieldStart("annotations")
		e.ArrStart()
		for _, elem := range s.Annotations {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfMessageContentTextObjectText = [2]string{
	0: "value",
	1: "annotations",
}

// Decode decodes MessageContentTextObjectText from json.
func (s *MessageContentTextObjectText) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageContentTextObjectText to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "annotations":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Annotations = make([]MessageContentTextObjectTextAnnotationsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageContentTextObjectTextAnnotationsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Annotations = append(s.Annotations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"annotations\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MessageContentTextObjectText")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMessageContentTextObjectText) {
					name = jsonFieldsNameOfMessageContentTextObjectText[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MessageContentTextObjectText) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageContentTextObjectText) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MessageContentTextObjectTextAnnotationsItem as json.
func (s MessageContentTextObjectTextAnnotationsItem) Encode(e *jx.Encoder) {
	switch s.Type {
	case MessageContentTextAnnotationsFileCitationObjectMessageContentTextObjectTextAnnotationsItem:
		s.MessageContentTextAnnotationsFileCitationObject.Encode(e)
	case MessageContentTextAnnotationsFilePathObjectMessageContentTextObjectTextAnnotationsItem:
		s.MessageContentTextAnnotationsFilePathObject.Encode(e)
	}
}

func (s MessageContentTextObjectTextAnnotationsItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case MessageContentTextAnnotationsFileCitationObjectMessageContentTextObjectTextAnnotationsItem:
		s.MessageContentTextAnnotationsFileCitationObject.encodeFields(e)
	case MessageContentTextAnnotationsFilePathObjectMessageContentTextObjectTextAnnotationsItem:
		s.MessageContentTextAnnotationsFilePathObject.encodeFields(e)
	}
}

// Decode decodes MessageContentTextObjectTextAnnotationsItem from json.
func (s *MessageContentTextObjectTextAnnotationsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageContentTextObjectTextAnnotationsItem to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "file_citation":
				match := MessageContentTextAnnotationsFileCitationObjectMessageContentTextObjectTextAnnotationsItem
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "file_path":
				match := MessageContentTextAnnotationsFilePathObjectMessageContentTextObjectTextAnnotationsItem
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case MessageContentTextAnnotationsFileCitationObjectMessageContentTextObjectTextAnnotationsItem:
		if err := s.MessageContentTextAnnotationsFileCitationObject.Decode(d); err != nil {
			return err
		}
	case MessageContentTextAnnotationsFilePathObjectMessageContentTextObjectTextAnnotationsItem:
		if err := s.MessageContentTextAnnotationsFilePathObject.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MessageContentTextObjectTextAnnotationsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageContentTextObjectTextAnnotationsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MessageContentTextObjectType as json.
func (s MessageContentTextObjectType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MessageContentTextObjectType from json.
func (s *MessageContentTextObjectType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageContentTextObjectType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MessageContentTextObjectType(v) {
	case MessageContentTextObjectTypeText:
		*s = MessageContentTextObjectTypeText
	default:
		*s = MessageContentTextObjectType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MessageContentTextObjectType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageContentTextObjectType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MessageFileObject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MessageFileObject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("object")
		s.Object.Encode(e)
	}
	{
		e.FieldStart("created_at")
		e.Int(s.CreatedAt)
	}
	{
		e.FieldStart("message_id")
		e.Str(s.MessageID)
	}
}

var jsonFieldsNameOfMessageFileObject = [4]string{
	0: "id",
	1: "object",
	2: "created_at",
	3: "message_id",
}

// Decode decodes MessageFileObject from json.
func (s *MessageFileObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageFileObject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "object":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CreatedAt = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "message_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.MessageID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MessageFileObject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMessageFileObject) {
					name = jsonFieldsNameOfMessageFileObject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MessageFileObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageFileObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MessageFileObjectObject as json.
func (s MessageFileObjectObject) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MessageFileObjectObject from json.
func (s *MessageFileObjectObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageFileObjectObject to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MessageFileObjectObject(v) {
	case MessageFileObjectObjectThreadMessageFile:
		*s = MessageFileObjectObjectThreadMessageFile
	default:
		*s = MessageFileObjectObject(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MessageFileObjectObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageFileObjectObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MessageObject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MessageObject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("object")
		s.Object.Encode(e)
	}
	{
		e.FieldStart("created_at")
		e.Int(s.CreatedAt)
	}
	{
		e.FieldStart("thread_id")
		e.Str(s.ThreadID)
	}
	{
		e.FieldStart("role")
		s.Role.Encode(e)
	}
	{
		e.FieldStart("content")
		e.ArrStart()
		for _, elem := range s.Content {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("assistant_id")
		s.AssistantID.Encode(e)
	}
	{
		e.FieldStart("run_id")
		s.RunID.Encode(e)
	}
	{
		e.FieldStart("file_ids")
		e.ArrStart()
		for _, elem := range s.FileIds {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("metadata")
		if s.Metadata == nil {
			e.Null()
		} else {
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfMessageObject = [10]string{
	0: "id",
	1: "object",
	2: "created_at",
	3: "thread_id",
	4: "role",
	5: "content",
	6: "assistant_id",
	7: "run_id",
	8: "file_ids",
	9: "metadata",
}

// Decode decodes MessageObject from json.
func (s *MessageObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageObject to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "object":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CreatedAt = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "thread_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ThreadID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thread_id\"")
			}
		case "role":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "content":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.Content = make([]MessageObjectContentItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessageObjectContentItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Content = append(s.Content, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "assistant_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.AssistantID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assistant_id\"")
			}
		case "run_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.RunID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"run_id\"")
			}
		case "file_ids":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				s.FileIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.FileIds = append(s.FileIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_ids\"")
			}
		case "metadata":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				s.Metadata = nil
				var elem MessageObjectMetadata
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Metadata = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MessageObject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMessageObject) {
					name = jsonFieldsNameOfMessageObject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MessageObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MessageObjectContentItem as json.
func (s MessageObjectContentItem) Encode(e *jx.Encoder) {
	switch s.Type {
	case MessageContentImageFileObjectMessageObjectContentItem:
		s.MessageContentImageFileObject.Encode(e)
	case MessageContentTextObjectMessageObjectContentItem:
		s.MessageContentTextObject.Encode(e)
	}
}

func (s MessageObjectContentItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case MessageContentImageFileObjectMessageObjectContentItem:
		s.MessageContentImageFileObject.encodeFields(e)
	case MessageContentTextObjectMessageObjectContentItem:
		s.MessageContentTextObject.encodeFields(e)
	}
}

// Decode decodes MessageObjectContentItem from json.
func (s *MessageObjectContentItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageObjectContentItem to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "image_file":
				match := MessageContentImageFileObjectMessageObjectContentItem
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "text":
				match := MessageContentTextObjectMessageObjectContentItem
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case MessageContentImageFileObjectMessageObjectContentItem:
		if err := s.MessageContentImageFileObject.Decode(d); err != nil {
			return err
		}
	case MessageContentTextObjectMessageObjectContentItem:
		if err := s.MessageContentTextObject.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MessageObjectContentItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageObjectContentItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MessageObjectMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MessageObjectMetadata) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfMessageObjectMetadata = [0]string{}

// Decode decodes MessageObjectMetadata from json.
func (s *MessageObjectMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageObjectMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode MessageObjectMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MessageObjectMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageObjectMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MessageObjectObject as json.
func (s MessageObjectObject) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MessageObjectObject from json.
func (s *MessageObjectObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageObjectObject to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MessageObjectObject(v) {
	case MessageObjectObjectThreadMessage:
		*s = MessageObjectObjectThreadMessage
	default:
		*s = MessageObjectObject(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MessageObjectObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageObjectObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MessageObjectRole as json.
func (s MessageObjectRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MessageObjectRole from json.
func (s *MessageObjectRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessageObjectRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MessageObjectRole(v) {
	case MessageObjectRoleUser:
		*s = MessageObjectRoleUser
	case MessageObjectRoleAssistant:
		*s = MessageObjectRoleAssistant
	default:
		*s = MessageObjectRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MessageObjectRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessageObjectRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Model) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Model) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("created")
		e.Int(s.Created)
	}
	{
		e.FieldStart("object")
		s.Object.Encode(e)
	}
	{
		e.FieldStart("owned_by")
		e.Str(s.OwnedBy)
	}
}

var jsonFieldsNameOfModel = [4]string{
	0: "id",
	1: "created",
	2: "object",
	3: "owned_by",
}

// Decode decodes Model from json.
func (s *Model) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Model to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Created = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created\"")
			}
		case "object":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "owned_by":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.OwnedBy = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owned_by\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Model")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfModel) {
					name = jsonFieldsNameOfModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Model) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Model) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ModelObject as json.
func (s ModelObject) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ModelObject from json.
func (s *ModelObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModelObject to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ModelObject(v) {
	case ModelObjectModel:
		*s = ModelObjectModel
	default:
		*s = ModelObject(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ModelObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModelObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ModifyAssistantRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ModifyAssistantRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Model.Set {
			e.FieldStart("model")
			s.Model.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Instructions.Set {
			e.FieldStart("instructions")
			s.Instructions.Encode(e)
		}
	}
	{
		if s.Tools != nil {
			e.FieldStart("tools")
			e.ArrStart()
			for _, elem := range s.Tools {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.FileIds != nil {
			e.FieldStart("file_ids")
			e.ArrStart()
			for _, elem := range s.FileIds {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfModifyAssistantRequest = [7]string{
	0: "model",
	1: "name",
	2: "description",
	3: "instructions",
	4: "tools",
	5: "file_ids",
	6: "metadata",
}

// Decode decodes ModifyAssistantRequest from json.
func (s *ModifyAssistantRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModifyAssistantRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "model":
			if err := func() error {
				s.Model.Reset()
				if err := s.Model.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "instructions":
			if err := func() error {
				s.Instructions.Reset()
				if err := s.Instructions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instructions\"")
			}
		case "tools":
			if err := func() error {
				s.Tools = make([]ModifyAssistantRequestToolsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ModifyAssistantRequestToolsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tools = append(s.Tools, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tools\"")
			}
		case "file_ids":
			if err := func() error {
				s.FileIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.FileIds = append(s.FileIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_ids\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ModifyAssistantRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ModifyAssistantRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModifyAssistantRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ModifyAssistantRequestMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ModifyAssistantRequestMetadata) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfModifyAssistantRequestMetadata = [0]string{}

// Decode decodes ModifyAssistantRequestMetadata from json.
func (s *ModifyAssistantRequestMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModifyAssistantRequestMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ModifyAssistantRequestMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ModifyAssistantRequestMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModifyAssistantRequestMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ModifyAssistantRequestModel as json.
func (s ModifyAssistantRequestModel) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringModifyAssistantRequestModel:
		e.Str(s.String)
	}
}

// Decode decodes ModifyAssistantRequestModel from json.
func (s *ModifyAssistantRequestModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModifyAssistantRequestModel to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringModifyAssistantRequestModel
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ModifyAssistantRequestModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModifyAssistantRequestModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ModifyAssistantRequestToolsItem as json.
func (s ModifyAssistantRequestToolsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s ModifyAssistantRequestToolsItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case AssistantToolsCodeModifyAssistantRequestToolsItem:
		e.FieldStart("type")
		e.Str("code_interpreter")
		s.AssistantToolsCode.encodeFields(e)
	case AssistantToolsFunctionModifyAssistantRequestToolsItem:
		e.FieldStart("type")
		e.Str("function")
		s.AssistantToolsFunction.encodeFields(e)
	case AssistantToolsRetrievalModifyAssistantRequestToolsItem:
		e.FieldStart("type")
		e.Str("retrieval")
		s.AssistantToolsRetrieval.encodeFields(e)
	}
}

// Decode decodes ModifyAssistantRequestToolsItem from json.
func (s *ModifyAssistantRequestToolsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModifyAssistantRequestToolsItem to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "code_interpreter":
					s.Type = AssistantToolsCodeModifyAssistantRequestToolsItem
					found = true
				case "function":
					s.Type = AssistantToolsFunctionModifyAssistantRequestToolsItem
					found = true
				case "retrieval":
					s.Type = AssistantToolsRetrievalModifyAssistantRequestToolsItem
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case AssistantToolsCodeModifyAssistantRequestToolsItem:
		if err := s.AssistantToolsCode.Decode(d); err != nil {
			return err
		}
	case AssistantToolsRetrievalModifyAssistantRequestToolsItem:
		if err := s.AssistantToolsRetrieval.Decode(d); err != nil {
			return err
		}
	case AssistantToolsFunctionModifyAssistantRequestToolsItem:
		if err := s.AssistantToolsFunction.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ModifyAssistantRequestToolsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModifyAssistantRequestToolsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ModifyMessageRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ModifyMessageRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfModifyMessageRequest = [1]string{
	0: "metadata",
}

// Decode decodes ModifyMessageRequest from json.
func (s *ModifyMessageRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModifyMessageRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ModifyMessageRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ModifyMessageRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModifyMessageRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ModifyMessageRequestMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ModifyMessageRequestMetadata) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfModifyMessageRequestMetadata = [0]string{}

// Decode decodes ModifyMessageRequestMetadata from json.
func (s *ModifyMessageRequestMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModifyMessageRequestMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ModifyMessageRequestMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ModifyMessageRequestMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModifyMessageRequestMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ModifyRunRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ModifyRunRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfModifyRunRequest = [1]string{
	0: "metadata",
}

// Decode decodes ModifyRunRequest from json.
func (s *ModifyRunRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModifyRunRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ModifyRunRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ModifyRunRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModifyRunRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ModifyRunRequestMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ModifyRunRequestMetadata) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfModifyRunRequestMetadata = [0]string{}

// Decode decodes ModifyRunRequestMetadata from json.
func (s *ModifyRunRequestMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModifyRunRequestMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ModifyRunRequestMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ModifyRunRequestMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModifyRunRequestMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ModifyThreadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ModifyThreadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfModifyThreadRequest = [1]string{
	0: "metadata",
}

// Decode decodes ModifyThreadRequest from json.
func (s *ModifyThreadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModifyThreadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ModifyThreadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ModifyThreadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModifyThreadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ModifyThreadRequestMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ModifyThreadRequestMetadata) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfModifyThreadRequestMetadata = [0]string{}

// Decode decodes ModifyThreadRequestMetadata from json.
func (s *ModifyThreadRequestMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModifyThreadRequestMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ModifyThreadRequestMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ModifyThreadRequestMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModifyThreadRequestMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateChatCompletionResponseChoicesItemLogprobs as json.
func (o NilCreateChatCompletionResponseChoicesItemLogprobs) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateChatCompletionResponseChoicesItemLogprobs from json.
func (o *NilCreateChatCompletionResponseChoicesItemLogprobs) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilCreateChatCompletionResponseChoicesItemLogprobs to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CreateChatCompletionResponseChoicesItemLogprobs
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilCreateChatCompletionResponseChoicesItemLogprobs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilCreateChatCompletionResponseChoicesItemLogprobs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FineTuningJobError as json.
func (o NilFineTuningJobError) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FineTuningJobError from json.
func (o *NilFineTuningJobError) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilFineTuningJobError to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v FineTuningJobError
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilFineTuningJobError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilFineTuningJobError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o NilInt) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *NilInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilInt to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v int
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RunCompletionUsage as json.
func (o NilRunCompletionUsage) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RunCompletionUsage from json.
func (o *NilRunCompletionUsage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilRunCompletionUsage to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v RunCompletionUsage
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilRunCompletionUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilRunCompletionUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RunObjectLastError as json.
func (o NilRunObjectLastError) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RunObjectLastError from json.
func (o *NilRunObjectLastError) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilRunObjectLastError to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v RunObjectLastError
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilRunObjectLastError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilRunObjectLastError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RunObjectRequiredAction as json.
func (o NilRunObjectRequiredAction) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RunObjectRequiredAction from json.
func (o *NilRunObjectRequiredAction) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilRunObjectRequiredAction to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v RunObjectRequiredAction
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilRunObjectRequiredAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilRunObjectRequiredAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RunStepCompletionUsage as json.
func (o NilRunStepCompletionUsage) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RunStepCompletionUsage from json.
func (o *NilRunStepCompletionUsage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilRunStepCompletionUsage to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v RunStepCompletionUsage
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilRunStepCompletionUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilRunStepCompletionUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RunStepObjectLastError as json.
func (o NilRunStepObjectLastError) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RunStepObjectLastError from json.
func (o *NilRunStepObjectLastError) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilRunStepObjectLastError to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v RunStepObjectLastError
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilRunStepObjectLastError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilRunStepObjectLastError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o NilString) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *NilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OpenAIFile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OpenAIFile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("bytes")
		e.Int(s.Bytes)
	}
	{
		e.FieldStart("created_at")
		e.Int(s.CreatedAt)
	}
	{
		e.FieldStart("filename")
		e.Str(s.Filename)
	}
	{
		e.FieldStart("object")
		s.Object.Encode(e)
	}
	{
		e.FieldStart("purpose")
		s.Purpose.Encode(e)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.StatusDetails.Set {
			e.FieldStart("status_details")
			s.StatusDetails.Encode(e)
		}
	}
}

var jsonFieldsNameOfOpenAIFile = [8]string{
	0: "id",
	1: "bytes",
	2: "created_at",
	3: "filename",
	4: "object",
	5: "purpose",
	6: "status",
	7: "status_details",
}

// Decode decodes OpenAIFile from json.
func (s *OpenAIFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OpenAIFile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "bytes":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Bytes = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bytes\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CreatedAt = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "filename":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Filename = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filename\"")
			}
		case "object":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "purpose":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Purpose.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"purpose\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "status_details":
			if err := func() error {
				s.StatusDetails.Reset()
				if err := s.StatusDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status_details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OpenAIFile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOpenAIFile) {
					name = jsonFieldsNameOfOpenAIFile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OpenAIFile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OpenAIFile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OpenAIFileObject as json.
func (s OpenAIFileObject) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OpenAIFileObject from json.
func (s *OpenAIFileObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OpenAIFileObject to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OpenAIFileObject(v) {
	case OpenAIFileObjectFile:
		*s = OpenAIFileObjectFile
	default:
		*s = OpenAIFileObject(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OpenAIFileObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OpenAIFileObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OpenAIFilePurpose as json.
func (s OpenAIFilePurpose) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OpenAIFilePurpose from json.
func (s *OpenAIFilePurpose) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OpenAIFilePurpose to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OpenAIFilePurpose(v) {
	case OpenAIFilePurposeFineTune:
		*s = OpenAIFilePurposeFineTune
	case OpenAIFilePurposeFineTuneResults:
		*s = OpenAIFilePurposeFineTuneResults
	case OpenAIFilePurposeAssistants:
		*s = OpenAIFilePurposeAssistants
	case OpenAIFilePurposeAssistantsOutput:
		*s = OpenAIFilePurposeAssistantsOutput
	default:
		*s = OpenAIFilePurpose(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OpenAIFilePurpose) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OpenAIFilePurpose) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OpenAIFileStatus as json.
func (s OpenAIFileStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OpenAIFileStatus from json.
func (s *OpenAIFileStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OpenAIFileStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OpenAIFileStatus(v) {
	case OpenAIFileStatusUploaded:
		*s = OpenAIFileStatusUploaded
	case OpenAIFileStatusProcessed:
		*s = OpenAIFileStatusProcessed
	case OpenAIFileStatusError:
		*s = OpenAIFileStatusError
	default:
		*s = OpenAIFileStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OpenAIFileStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OpenAIFileStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatCompletionResponseMessageFunctionCall as json.
func (o OptChatCompletionResponseMessageFunctionCall) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChatCompletionResponseMessageFunctionCall from json.
func (o *OptChatCompletionResponseMessageFunctionCall) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptChatCompletionResponseMessageFunctionCall to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptChatCompletionResponseMessageFunctionCall) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptChatCompletionResponseMessageFunctionCall) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatCompletionToolChoiceOption as json.
func (o OptChatCompletionToolChoiceOption) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChatCompletionToolChoiceOption from json.
func (o *OptChatCompletionToolChoiceOption) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptChatCompletionToolChoiceOption to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptChatCompletionToolChoiceOption) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptChatCompletionToolChoiceOption) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CompletionUsage as json.
func (o OptCompletionUsage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CompletionUsage from json.
func (o *OptCompletionUsage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCompletionUsage to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCompletionUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCompletionUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes *CreateAssistantRequestMetadata as json.
func (o OptCreateAssistantRequestMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes *CreateAssistantRequestMetadata from json.
func (o *OptCreateAssistantRequestMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateAssistantRequestMetadata to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateAssistantRequestMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateAssistantRequestMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateChatCompletionRequestFunctionCall as json.
func (o OptCreateChatCompletionRequestFunctionCall) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateChatCompletionRequestFunctionCall from json.
func (o *OptCreateChatCompletionRequestFunctionCall) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateChatCompletionRequestFunctionCall to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateChatCompletionRequestFunctionCall) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateChatCompletionRequestFunctionCall) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateChatCompletionRequestResponseFormat as json.
func (o OptCreateChatCompletionRequestResponseFormat) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateChatCompletionRequestResponseFormat from json.
func (o *OptCreateChatCompletionRequestResponseFormat) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateChatCompletionRequestResponseFormat to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateChatCompletionRequestResponseFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateChatCompletionRequestResponseFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateChatCompletionRequestResponseFormatType as json.
func (o OptCreateChatCompletionRequestResponseFormatType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateChatCompletionRequestResponseFormatType from json.
func (o *OptCreateChatCompletionRequestResponseFormatType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateChatCompletionRequestResponseFormatType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateChatCompletionRequestResponseFormatType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateChatCompletionRequestResponseFormatType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateChatCompletionRequestStop as json.
func (o OptCreateChatCompletionRequestStop) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateChatCompletionRequestStop from json.
func (o *OptCreateChatCompletionRequestStop) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateChatCompletionRequestStop to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateChatCompletionRequestStop) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateChatCompletionRequestStop) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateFineTuningJobRequestHyperparameters as json.
func (o OptCreateFineTuningJobRequestHyperparameters) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateFineTuningJobRequestHyperparameters from json.
func (o *OptCreateFineTuningJobRequestHyperparameters) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateFineTuningJobRequestHyperparameters to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateFineTuningJobRequestHyperparameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateFineTuningJobRequestHyperparameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateFineTuningJobRequestHyperparametersBatchSize as json.
func (o OptCreateFineTuningJobRequestHyperparametersBatchSize) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateFineTuningJobRequestHyperparametersBatchSize from json.
func (o *OptCreateFineTuningJobRequestHyperparametersBatchSize) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateFineTuningJobRequestHyperparametersBatchSize to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateFineTuningJobRequestHyperparametersBatchSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateFineTuningJobRequestHyperparametersBatchSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateFineTuningJobRequestHyperparametersLearningRateMultiplier as json.
func (o OptCreateFineTuningJobRequestHyperparametersLearningRateMultiplier) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateFineTuningJobRequestHyperparametersLearningRateMultiplier from json.
func (o *OptCreateFineTuningJobRequestHyperparametersLearningRateMultiplier) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateFineTuningJobRequestHyperparametersLearningRateMultiplier to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateFineTuningJobRequestHyperparametersLearningRateMultiplier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateFineTuningJobRequestHyperparametersLearningRateMultiplier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateFineTuningJobRequestHyperparametersNEpochs as json.
func (o OptCreateFineTuningJobRequestHyperparametersNEpochs) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateFineTuningJobRequestHyperparametersNEpochs from json.
func (o *OptCreateFineTuningJobRequestHyperparametersNEpochs) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateFineTuningJobRequestHyperparametersNEpochs to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateFineTuningJobRequestHyperparametersNEpochs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateFineTuningJobRequestHyperparametersNEpochs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateImageRequestQuality as json.
func (o OptCreateImageRequestQuality) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateImageRequestQuality from json.
func (o *OptCreateImageRequestQuality) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateImageRequestQuality to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateImageRequestQuality) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateImageRequestQuality) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes *CreateMessageRequestMetadata as json.
func (o OptCreateMessageRequestMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes *CreateMessageRequestMetadata from json.
func (o *OptCreateMessageRequestMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateMessageRequestMetadata to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateMessageRequestMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateMessageRequestMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes *CreateRunRequestMetadata as json.
func (o OptCreateRunRequestMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes *CreateRunRequestMetadata from json.
func (o *OptCreateRunRequestMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateRunRequestMetadata to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateRunRequestMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateRunRequestMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateSpeechRequestResponseFormat as json.
func (o OptCreateSpeechRequestResponseFormat) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateSpeechRequestResponseFormat from json.
func (o *OptCreateSpeechRequestResponseFormat) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateSpeechRequestResponseFormat to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateSpeechRequestResponseFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateSpeechRequestResponseFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes *CreateThreadAndRunRequestMetadata as json.
func (o OptCreateThreadAndRunRequestMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes *CreateThreadAndRunRequestMetadata from json.
func (o *OptCreateThreadAndRunRequestMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateThreadAndRunRequestMetadata to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateThreadAndRunRequestMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateThreadAndRunRequestMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateThreadRequest as json.
func (o OptCreateThreadRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateThreadRequest from json.
func (o *OptCreateThreadRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateThreadRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateThreadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateThreadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes *CreateThreadRequestMetadata as json.
func (o OptCreateThreadRequestMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes *CreateThreadRequestMetadata from json.
func (o *OptCreateThreadRequestMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateThreadRequestMetadata to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateThreadRequestMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateThreadRequestMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FunctionParameters as json.
func (o OptFunctionParameters) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FunctionParameters from json.
func (o *OptFunctionParameters) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFunctionParameters to nil")
	}
	o.Set = true
	o.Value = make(FunctionParameters)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFunctionParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFunctionParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt64 to nil")
	}
	o.Set = true
	v, err := d.Int64()
	if err != nil {
		return err
	}
	o.Value = int64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes *ModifyAssistantRequestMetadata as json.
func (o OptModifyAssistantRequestMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes *ModifyAssistantRequestMetadata from json.
func (o *OptModifyAssistantRequestMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptModifyAssistantRequestMetadata to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptModifyAssistantRequestMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptModifyAssistantRequestMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ModifyAssistantRequestModel as json.
func (o OptModifyAssistantRequestModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ModifyAssistantRequestModel from json.
func (o *OptModifyAssistantRequestModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptModifyAssistantRequestModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptModifyAssistantRequestModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptModifyAssistantRequestModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes *ModifyMessageRequestMetadata as json.
func (o OptModifyMessageRequestMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes *ModifyMessageRequestMetadata from json.
func (o *OptModifyMessageRequestMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptModifyMessageRequestMetadata to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptModifyMessageRequestMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptModifyMessageRequestMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes *ModifyRunRequestMetadata as json.
func (o OptModifyRunRequestMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes *ModifyRunRequestMetadata from json.
func (o *OptModifyRunRequestMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptModifyRunRequestMetadata to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptModifyRunRequestMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptModifyRunRequestMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes *ModifyThreadRequestMetadata as json.
func (o OptModifyThreadRequestMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes *ModifyThreadRequestMetadata from json.
func (o *OptModifyThreadRequestMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptModifyThreadRequestMetadata to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptModifyThreadRequestMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptModifyThreadRequestMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptNilBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptNilBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilBool to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v bool
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateChatCompletionRequestLogitBias as json.
func (o OptNilCreateChatCompletionRequestLogitBias) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateChatCompletionRequestLogitBias from json.
func (o *OptNilCreateChatCompletionRequestLogitBias) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCreateChatCompletionRequestLogitBias to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CreateChatCompletionRequestLogitBias
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(CreateChatCompletionRequestLogitBias)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCreateChatCompletionRequestLogitBias) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCreateChatCompletionRequestLogitBias) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateImageRequestResponseFormat as json.
func (o OptNilCreateImageRequestResponseFormat) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateImageRequestResponseFormat from json.
func (o *OptNilCreateImageRequestResponseFormat) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCreateImageRequestResponseFormat to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CreateImageRequestResponseFormat
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCreateImageRequestResponseFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCreateImageRequestResponseFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateImageRequestSize as json.
func (o OptNilCreateImageRequestSize) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateImageRequestSize from json.
func (o *OptNilCreateImageRequestSize) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCreateImageRequestSize to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CreateImageRequestSize
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCreateImageRequestSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCreateImageRequestSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateImageRequestStyle as json.
func (o OptNilCreateImageRequestStyle) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateImageRequestStyle from json.
func (o *OptNilCreateImageRequestStyle) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCreateImageRequestStyle to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CreateImageRequestStyle
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCreateImageRequestStyle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCreateImageRequestStyle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []CreateRunRequestToolsItem as json.
func (o OptNilCreateRunRequestToolsItemArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []CreateRunRequestToolsItem from json.
func (o *OptNilCreateRunRequestToolsItemArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCreateRunRequestToolsItemArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []CreateRunRequestToolsItem
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]CreateRunRequestToolsItem, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem CreateRunRequestToolsItem
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCreateRunRequestToolsItemArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCreateRunRequestToolsItemArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []CreateThreadAndRunRequestToolsItem as json.
func (o OptNilCreateThreadAndRunRequestToolsItemArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []CreateThreadAndRunRequestToolsItem from json.
func (o *OptNilCreateThreadAndRunRequestToolsItemArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCreateThreadAndRunRequestToolsItemArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []CreateThreadAndRunRequestToolsItem
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]CreateThreadAndRunRequestToolsItem, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem CreateThreadAndRunRequestToolsItem
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCreateThreadAndRunRequestToolsItemArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCreateThreadAndRunRequestToolsItemArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptNilFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptNilFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilFloat64 to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v float64
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptNilInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptNilInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInt to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v int
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RunCompletionUsage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RunCompletionUsage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("completion_tokens")
		e.Int(s.CompletionTokens)
	}
	{
		e.FieldStart("prompt_tokens")
		e.Int(s.PromptTokens)
	}
	{
		e.FieldStart("total_tokens")
		e.Int(s.TotalTokens)
	}
}

var jsonFieldsNameOfRunCompletionUsage = [3]string{
	0: "completion_tokens",
	1: "prompt_tokens",
	2: "total_tokens",
}

// Decode decodes RunCompletionUsage from json.
func (s *RunCompletionUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunCompletionUsage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "completion_tokens":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.CompletionTokens = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completion_tokens\"")
			}
		case "prompt_tokens":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.PromptTokens = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prompt_tokens\"")
			}
		case "total_tokens":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.TotalTokens = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_tokens\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RunCompletionUsage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRunCompletionUsage) {
					name = jsonFieldsNameOfRunCompletionUsage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RunCompletionUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunCompletionUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RunObject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RunObject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("object")
		s.Object.Encode(e)
	}
	{
		e.FieldStart("created_at")
		e.Int(s.CreatedAt)
	}
	{
		e.FieldStart("thread_id")
		e.Str(s.ThreadID)
	}
	{
		e.FieldStart("assistant_id")
		e.Str(s.AssistantID)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("required_action")
		s.RequiredAction.Encode(e)
	}
	{
		e.FieldStart("last_error")
		s.LastError.Encode(e)
	}
	{
		e.FieldStart("expires_at")
		e.Int(s.ExpiresAt)
	}
	{
		e.FieldStart("started_at")
		s.StartedAt.Encode(e)
	}
	{
		e.FieldStart("cancelled_at")
		s.CancelledAt.Encode(e)
	}
	{
		e.FieldStart("failed_at")
		s.FailedAt.Encode(e)
	}
	{
		e.FieldStart("completed_at")
		s.CompletedAt.Encode(e)
	}
	{
		e.FieldStart("model")
		e.Str(s.Model)
	}
	{
		e.FieldStart("instructions")
		e.Str(s.Instructions)
	}
	{
		e.FieldStart("tools")
		e.ArrStart()
		for _, elem := range s.Tools {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("file_ids")
		e.ArrStart()
		for _, elem := range s.FileIds {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("metadata")
		if s.Metadata == nil {
			e.Null()
		} else {
			s.Metadata.Encode(e)
		}
	}
	{
		e.FieldStart("usage")
		s.Usage.Encode(e)
	}
}

var jsonFieldsNameOfRunObject = [19]string{
	0:  "id",
	1:  "object",
	2:  "created_at",
	3:  "thread_id",
	4:  "assistant_id",
	5:  "status",
	6:  "required_action",
	7:  "last_error",
	8:  "expires_at",
	9:  "started_at",
	10: "cancelled_at",
	11: "failed_at",
	12: "completed_at",
	13: "model",
	14: "instructions",
	15: "tools",
	16: "file_ids",
	17: "metadata",
	18: "usage",
}

// Decode decodes RunObject from json.
func (s *RunObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunObject to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "object":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CreatedAt = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "thread_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ThreadID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thread_id\"")
			}
		case "assistant_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.AssistantID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assistant_id\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "required_action":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.RequiredAction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_action\"")
			}
		case "last_error":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.LastError.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_error\"")
			}
		case "expires_at":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ExpiresAt = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		case "started_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.StartedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "cancelled_at":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.CancelledAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cancelled_at\"")
			}
		case "failed_at":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.FailedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failed_at\"")
			}
		case "completed_at":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.CompletedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completed_at\"")
			}
		case "model":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Model = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		case "instructions":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Instructions = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instructions\"")
			}
		case "tools":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				s.Tools = make([]RunObjectToolsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RunObjectToolsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tools = append(s.Tools, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tools\"")
			}
		case "file_ids":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				s.FileIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.FileIds = append(s.FileIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_ids\"")
			}
		case "metadata":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				s.Metadata = nil
				var elem RunObjectMetadata
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Metadata = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "usage":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Usage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RunObject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRunObject) {
					name = jsonFieldsNameOfRunObject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RunObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RunObjectLastError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RunObjectLastError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		s.Code.Encode(e)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfRunObjectLastError = [2]string{
	0: "code",
	1: "message",
}

// Decode decodes RunObjectLastError from json.
func (s *RunObjectLastError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunObjectLastError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RunObjectLastError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRunObjectLastError) {
					name = jsonFieldsNameOfRunObjectLastError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RunObjectLastError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunObjectLastError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RunObjectLastErrorCode as json.
func (s RunObjectLastErrorCode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RunObjectLastErrorCode from json.
func (s *RunObjectLastErrorCode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunObjectLastErrorCode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RunObjectLastErrorCode(v) {
	case RunObjectLastErrorCodeServerError:
		*s = RunObjectLastErrorCodeServerError
	case RunObjectLastErrorCodeRateLimitExceeded:
		*s = RunObjectLastErrorCodeRateLimitExceeded
	case RunObjectLastErrorCodeInvalidPrompt:
		*s = RunObjectLastErrorCodeInvalidPrompt
	default:
		*s = RunObjectLastErrorCode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RunObjectLastErrorCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunObjectLastErrorCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RunObjectMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RunObjectMetadata) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfRunObjectMetadata = [0]string{}

// Decode decodes RunObjectMetadata from json.
func (s *RunObjectMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunObjectMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode RunObjectMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RunObjectMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunObjectMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RunObjectObject as json.
func (s RunObjectObject) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RunObjectObject from json.
func (s *RunObjectObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunObjectObject to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RunObjectObject(v) {
	case RunObjectObjectThreadRun:
		*s = RunObjectObjectThreadRun
	default:
		*s = RunObjectObject(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RunObjectObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunObjectObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RunObjectRequiredAction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RunObjectRequiredAction) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("submit_tool_outputs")
		s.SubmitToolOutputs.Encode(e)
	}
}

var jsonFieldsNameOfRunObjectRequiredAction = [2]string{
	0: "type",
	1: "submit_tool_outputs",
}

// Decode decodes RunObjectRequiredAction from json.
func (s *RunObjectRequiredAction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunObjectRequiredAction to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "submit_tool_outputs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.SubmitToolOutputs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"submit_tool_outputs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RunObjectRequiredAction")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRunObjectRequiredAction) {
					name = jsonFieldsNameOfRunObjectRequiredAction[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RunObjectRequiredAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunObjectRequiredAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RunObjectRequiredActionSubmitToolOutputs) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RunObjectRequiredActionSubmitToolOutputs) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("tool_calls")
		e.ArrStart()
		for _, elem := range s.ToolCalls {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfRunObjectRequiredActionSubmitToolOutputs = [1]string{
	0: "tool_calls",
}

// Decode decodes RunObjectRequiredActionSubmitToolOutputs from json.
func (s *RunObjectRequiredActionSubmitToolOutputs) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunObjectRequiredActionSubmitToolOutputs to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tool_calls":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.ToolCalls = make([]RunToolCallObject, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RunToolCallObject
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ToolCalls = append(s.ToolCalls, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_calls\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RunObjectRequiredActionSubmitToolOutputs")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRunObjectRequiredActionSubmitToolOutputs) {
					name = jsonFieldsNameOfRunObjectRequiredActionSubmitToolOutputs[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RunObjectRequiredActionSubmitToolOutputs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunObjectRequiredActionSubmitToolOutputs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RunObjectRequiredActionType as json.
func (s RunObjectRequiredActionType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RunObjectRequiredActionType from json.
func (s *RunObjectRequiredActionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunObjectRequiredActionType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RunObjectRequiredActionType(v) {
	case RunObjectRequiredActionTypeSubmitToolOutputs:
		*s = RunObjectRequiredActionTypeSubmitToolOutputs
	default:
		*s = RunObjectRequiredActionType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RunObjectRequiredActionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunObjectRequiredActionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RunObjectStatus as json.
func (s RunObjectStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RunObjectStatus from json.
func (s *RunObjectStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunObjectStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RunObjectStatus(v) {
	case RunObjectStatusQueued:
		*s = RunObjectStatusQueued
	case RunObjectStatusInProgress:
		*s = RunObjectStatusInProgress
	case RunObjectStatusRequiresAction:
		*s = RunObjectStatusRequiresAction
	case RunObjectStatusCancelling:
		*s = RunObjectStatusCancelling
	case RunObjectStatusCancelled:
		*s = RunObjectStatusCancelled
	case RunObjectStatusFailed:
		*s = RunObjectStatusFailed
	case RunObjectStatusCompleted:
		*s = RunObjectStatusCompleted
	case RunObjectStatusExpired:
		*s = RunObjectStatusExpired
	default:
		*s = RunObjectStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RunObjectStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunObjectStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RunObjectToolsItem as json.
func (s RunObjectToolsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s RunObjectToolsItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case AssistantToolsCodeRunObjectToolsItem:
		e.FieldStart("type")
		e.Str("code_interpreter")
		s.AssistantToolsCode.encodeFields(e)
	case AssistantToolsFunctionRunObjectToolsItem:
		e.FieldStart("type")
		e.Str("function")
		s.AssistantToolsFunction.encodeFields(e)
	case AssistantToolsRetrievalRunObjectToolsItem:
		e.FieldStart("type")
		e.Str("retrieval")
		s.AssistantToolsRetrieval.encodeFields(e)
	}
}

// Decode decodes RunObjectToolsItem from json.
func (s *RunObjectToolsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunObjectToolsItem to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "code_interpreter":
					s.Type = AssistantToolsCodeRunObjectToolsItem
					found = true
				case "function":
					s.Type = AssistantToolsFunctionRunObjectToolsItem
					found = true
				case "retrieval":
					s.Type = AssistantToolsRetrievalRunObjectToolsItem
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case AssistantToolsCodeRunObjectToolsItem:
		if err := s.AssistantToolsCode.Decode(d); err != nil {
			return err
		}
	case AssistantToolsRetrievalRunObjectToolsItem:
		if err := s.AssistantToolsRetrieval.Decode(d); err != nil {
			return err
		}
	case AssistantToolsFunctionRunObjectToolsItem:
		if err := s.AssistantToolsFunction.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RunObjectToolsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunObjectToolsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RunStepCompletionUsage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RunStepCompletionUsage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("completion_tokens")
		e.Int(s.CompletionTokens)
	}
	{
		e.FieldStart("prompt_tokens")
		e.Int(s.PromptTokens)
	}
	{
		e.FieldStart("total_tokens")
		e.Int(s.TotalTokens)
	}
}

var jsonFieldsNameOfRunStepCompletionUsage = [3]string{
	0: "completion_tokens",
	1: "prompt_tokens",
	2: "total_tokens",
}

// Decode decodes RunStepCompletionUsage from json.
func (s *RunStepCompletionUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunStepCompletionUsage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "completion_tokens":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.CompletionTokens = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completion_tokens\"")
			}
		case "prompt_tokens":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.PromptTokens = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prompt_tokens\"")
			}
		case "total_tokens":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.TotalTokens = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_tokens\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RunStepCompletionUsage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRunStepCompletionUsage) {
					name = jsonFieldsNameOfRunStepCompletionUsage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RunStepCompletionUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunStepCompletionUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RunStepDetailsMessageCreationObject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RunStepDetailsMessageCreationObject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("message_creation")
		s.MessageCreation.Encode(e)
	}
}

var jsonFieldsNameOfRunStepDetailsMessageCreationObject = [2]string{
	0: "type",
	1: "message_creation",
}

// Decode decodes RunStepDetailsMessageCreationObject from json.
func (s *RunStepDetailsMessageCreationObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunStepDetailsMessageCreationObject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "message_creation":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.MessageCreation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_creation\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RunStepDetailsMessageCreationObject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRunStepDetailsMessageCreationObject) {
					name = jsonFieldsNameOfRunStepDetailsMessageCreationObject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RunStepDetailsMessageCreationObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunStepDetailsMessageCreationObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RunStepDetailsMessageCreationObjectMessageCreation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RunStepDetailsMessageCreationObjectMessageCreation) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message_id")
		e.Str(s.MessageID)
	}
}

var jsonFieldsNameOfRunStepDetailsMessageCreationObjectMessageCreation = [1]string{
	0: "message_id",
}

// Decode decodes RunStepDetailsMessageCreationObjectMessageCreation from json.
func (s *RunStepDetailsMessageCreationObjectMessageCreation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunStepDetailsMessageCreationObjectMessageCreation to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.MessageID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RunStepDetailsMessageCreationObjectMessageCreation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRunStepDetailsMessageCreationObjectMessageCreation) {
					name = jsonFieldsNameOfRunStepDetailsMessageCreationObjectMessageCreation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RunStepDetailsMessageCreationObjectMessageCreation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunStepDetailsMessageCreationObjectMessageCreation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RunStepDetailsMessageCreationObjectType as json.
func (s RunStepDetailsMessageCreationObjectType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RunStepDetailsMessageCreationObjectType from json.
func (s *RunStepDetailsMessageCreationObjectType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunStepDetailsMessageCreationObjectType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RunStepDetailsMessageCreationObjectType(v) {
	case RunStepDetailsMessageCreationObjectTypeMessageCreation:
		*s = RunStepDetailsMessageCreationObjectTypeMessageCreation
	default:
		*s = RunStepDetailsMessageCreationObjectType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RunStepDetailsMessageCreationObjectType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunStepDetailsMessageCreationObjectType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RunStepDetailsToolCallsCodeObject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RunStepDetailsToolCallsCodeObject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("code_interpreter")
		s.CodeInterpreter.Encode(e)
	}
}

var jsonFieldsNameOfRunStepDetailsToolCallsCodeObject = [2]string{
	0: "id",
	1: "code_interpreter",
}

// Decode decodes RunStepDetailsToolCallsCodeObject from json.
func (s *RunStepDetailsToolCallsCodeObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunStepDetailsToolCallsCodeObject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "code_interpreter":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.CodeInterpreter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code_interpreter\"")
			}
		case "type":
			return d.Skip()
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RunStepDetailsToolCallsCodeObject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRunStepDetailsToolCallsCodeObject) {
					name = jsonFieldsNameOfRunStepDetailsToolCallsCodeObject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RunStepDetailsToolCallsCodeObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunStepDetailsToolCallsCodeObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RunStepDetailsToolCallsCodeObjectCodeInterpreter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RunStepDetailsToolCallsCodeObjectCodeInterpreter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("input")
		e.Str(s.Input)
	}
	{
		e.FieldStart("outputs")
		e.ArrStart()
		for _, elem := range s.Outputs {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfRunStepDetailsToolCallsCodeObjectCodeInterpreter = [2]string{
	0: "input",
	1: "outputs",
}

// Decode decodes RunStepDetailsToolCallsCodeObjectCodeInterpreter from json.
func (s *RunStepDetailsToolCallsCodeObjectCodeInterpreter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunStepDetailsToolCallsCodeObjectCodeInterpreter to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "input":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Input = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input\"")
			}
		case "outputs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Outputs = make([]RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Outputs = append(s.Outputs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outputs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RunStepDetailsToolCallsCodeObjectCodeInterpreter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRunStepDetailsToolCallsCodeObjectCodeInterpreter) {
					name = jsonFieldsNameOfRunStepDetailsToolCallsCodeObjectCodeInterpreter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RunStepDetailsToolCallsCodeObjectCodeInterpreter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunStepDetailsToolCallsCodeObjectCodeInterpreter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsItem) encodeFields(e *jx.Encoder) {
	s.OneOf.encodeFields(e)
}

var jsonFieldsNameOfRunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsItem = [0]string{}

// Decode decodes RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsItem from json.
func (s *RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsItem to nil")
	}
	if err := d.Capture(func(d *jx.Decoder) error {
		return s.OneOf.Decode(d)
	}); err != nil {
		return errors.Wrap(err, "decode field OneOf")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsItemSum as json.
func (s RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsItemSum) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsItemSum) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case RunStepDetailsToolCallsCodeOutputImageObjectRunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsItemSum:
		e.FieldStart("type")
		e.Str("image")
		s.RunStepDetailsToolCallsCodeOutputImageObject.encodeFields(e)
	case RunStepDetailsToolCallsCodeOutputLogsObjectRunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsItemSum:
		e.FieldStart("type")
		e.Str("logs")
		s.RunStepDetailsToolCallsCodeOutputLogsObject.encodeFields(e)
	}
}

// Decode decodes RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsItemSum from json.
func (s *RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsItemSum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsItemSum to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "image":
					s.Type = RunStepDetailsToolCallsCodeOutputImageObjectRunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsItemSum
					found = true
				case "logs":
					s.Type = RunStepDetailsToolCallsCodeOutputLogsObjectRunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsItemSum
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case RunStepDetailsToolCallsCodeOutputLogsObjectRunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsItemSum:
		if err := s.RunStepDetailsToolCallsCodeOutputLogsObject.Decode(d); err != nil {
			return err
		}
	case RunStepDetailsToolCallsCodeOutputImageObjectRunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsItemSum:
		if err := s.RunStepDetailsToolCallsCodeOutputImageObject.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsItemSum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsItemSum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RunStepDetailsToolCallsCodeOutputImageObject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RunStepDetailsToolCallsCodeOutputImageObject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("image")
		s.Image.Encode(e)
	}
}

var jsonFieldsNameOfRunStepDetailsToolCallsCodeOutputImageObject = [1]string{
	0: "image",
}

// Decode decodes RunStepDetailsToolCallsCodeOutputImageObject from json.
func (s *RunStepDetailsToolCallsCodeOutputImageObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunStepDetailsToolCallsCodeOutputImageObject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "image":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Image.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image\"")
			}
		case "type":
			return d.Skip()
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RunStepDetailsToolCallsCodeOutputImageObject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRunStepDetailsToolCallsCodeOutputImageObject) {
					name = jsonFieldsNameOfRunStepDetailsToolCallsCodeOutputImageObject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RunStepDetailsToolCallsCodeOutputImageObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunStepDetailsToolCallsCodeOutputImageObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RunStepDetailsToolCallsCodeOutputImageObjectImage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RunStepDetailsToolCallsCodeOutputImageObjectImage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("file_id")
		e.Str(s.FileID)
	}
}

var jsonFieldsNameOfRunStepDetailsToolCallsCodeOutputImageObjectImage = [1]string{
	0: "file_id",
}

// Decode decodes RunStepDetailsToolCallsCodeOutputImageObjectImage from json.
func (s *RunStepDetailsToolCallsCodeOutputImageObjectImage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunStepDetailsToolCallsCodeOutputImageObjectImage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RunStepDetailsToolCallsCodeOutputImageObjectImage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRunStepDetailsToolCallsCodeOutputImageObjectImage) {
					name = jsonFieldsNameOfRunStepDetailsToolCallsCodeOutputImageObjectImage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RunStepDetailsToolCallsCodeOutputImageObjectImage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunStepDetailsToolCallsCodeOutputImageObjectImage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RunStepDetailsToolCallsCodeOutputLogsObject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RunStepDetailsToolCallsCodeOutputLogsObject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("logs")
		e.Str(s.Logs)
	}
}

var jsonFieldsNameOfRunStepDetailsToolCallsCodeOutputLogsObject = [1]string{
	0: "logs",
}

// Decode decodes RunStepDetailsToolCallsCodeOutputLogsObject from json.
func (s *RunStepDetailsToolCallsCodeOutputLogsObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunStepDetailsToolCallsCodeOutputLogsObject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "logs":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Logs = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logs\"")
			}
		case "type":
			return d.Skip()
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RunStepDetailsToolCallsCodeOutputLogsObject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRunStepDetailsToolCallsCodeOutputLogsObject) {
					name = jsonFieldsNameOfRunStepDetailsToolCallsCodeOutputLogsObject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RunStepDetailsToolCallsCodeOutputLogsObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunStepDetailsToolCallsCodeOutputLogsObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RunStepDetailsToolCallsFunctionObject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RunStepDetailsToolCallsFunctionObject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("function")
		s.Function.Encode(e)
	}
}

var jsonFieldsNameOfRunStepDetailsToolCallsFunctionObject = [2]string{
	0: "id",
	1: "function",
}

// Decode decodes RunStepDetailsToolCallsFunctionObject from json.
func (s *RunStepDetailsToolCallsFunctionObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunStepDetailsToolCallsFunctionObject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "function":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Function.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"function\"")
			}
		case "type":
			return d.Skip()
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RunStepDetailsToolCallsFunctionObject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRunStepDetailsToolCallsFunctionObject) {
					name = jsonFieldsNameOfRunStepDetailsToolCallsFunctionObject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RunStepDetailsToolCallsFunctionObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunStepDetailsToolCallsFunctionObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RunStepDetailsToolCallsFunctionObjectFunction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RunStepDetailsToolCallsFunctionObjectFunction) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("arguments")
		e.Str(s.Arguments)
	}
	{
		e.FieldStart("output")
		s.Output.Encode(e)
	}
}

var jsonFieldsNameOfRunStepDetailsToolCallsFunctionObjectFunction = [3]string{
	0: "name",
	1: "arguments",
	2: "output",
}

// Decode decodes RunStepDetailsToolCallsFunctionObjectFunction from json.
func (s *RunStepDetailsToolCallsFunctionObjectFunction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunStepDetailsToolCallsFunctionObjectFunction to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "arguments":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Arguments = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"arguments\"")
			}
		case "output":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Output.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"output\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RunStepDetailsToolCallsFunctionObjectFunction")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRunStepDetailsToolCallsFunctionObjectFunction) {
					name = jsonFieldsNameOfRunStepDetailsToolCallsFunctionObjectFunction[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RunStepDetailsToolCallsFunctionObjectFunction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunStepDetailsToolCallsFunctionObjectFunction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RunStepDetailsToolCallsObject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RunStepDetailsToolCallsObject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("tool_calls")
		e.ArrStart()
		for _, elem := range s.ToolCalls {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfRunStepDetailsToolCallsObject = [2]string{
	0: "type",
	1: "tool_calls",
}

// Decode decodes RunStepDetailsToolCallsObject from json.
func (s *RunStepDetailsToolCallsObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunStepDetailsToolCallsObject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "tool_calls":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ToolCalls = make([]RunStepDetailsToolCallsObjectToolCallsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RunStepDetailsToolCallsObjectToolCallsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ToolCalls = append(s.ToolCalls, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_calls\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RunStepDetailsToolCallsObject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRunStepDetailsToolCallsObject) {
					name = jsonFieldsNameOfRunStepDetailsToolCallsObject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RunStepDetailsToolCallsObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunStepDetailsToolCallsObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RunStepDetailsToolCallsObjectToolCallsItem as json.
func (s RunStepDetailsToolCallsObjectToolCallsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s RunStepDetailsToolCallsObjectToolCallsItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case RunStepDetailsToolCallsCodeObjectRunStepDetailsToolCallsObjectToolCallsItem:
		e.FieldStart("type")
		e.Str("code_interpreter")
		s.RunStepDetailsToolCallsCodeObject.encodeFields(e)
	case RunStepDetailsToolCallsFunctionObjectRunStepDetailsToolCallsObjectToolCallsItem:
		e.FieldStart("type")
		e.Str("function")
		s.RunStepDetailsToolCallsFunctionObject.encodeFields(e)
	case RunStepDetailsToolCallsRetrievalObjectRunStepDetailsToolCallsObjectToolCallsItem:
		e.FieldStart("type")
		e.Str("retrieval")
		s.RunStepDetailsToolCallsRetrievalObject.encodeFields(e)
	}
}

// Decode decodes RunStepDetailsToolCallsObjectToolCallsItem from json.
func (s *RunStepDetailsToolCallsObjectToolCallsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunStepDetailsToolCallsObjectToolCallsItem to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "code_interpreter":
					s.Type = RunStepDetailsToolCallsCodeObjectRunStepDetailsToolCallsObjectToolCallsItem
					found = true
				case "function":
					s.Type = RunStepDetailsToolCallsFunctionObjectRunStepDetailsToolCallsObjectToolCallsItem
					found = true
				case "retrieval":
					s.Type = RunStepDetailsToolCallsRetrievalObjectRunStepDetailsToolCallsObjectToolCallsItem
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case RunStepDetailsToolCallsCodeObjectRunStepDetailsToolCallsObjectToolCallsItem:
		if err := s.RunStepDetailsToolCallsCodeObject.Decode(d); err != nil {
			return err
		}
	case RunStepDetailsToolCallsRetrievalObjectRunStepDetailsToolCallsObjectToolCallsItem:
		if err := s.RunStepDetailsToolCallsRetrievalObject.Decode(d); err != nil {
			return err
		}
	case RunStepDetailsToolCallsFunctionObjectRunStepDetailsToolCallsObjectToolCallsItem:
		if err := s.RunStepDetailsToolCallsFunctionObject.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RunStepDetailsToolCallsObjectToolCallsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunStepDetailsToolCallsObjectToolCallsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RunStepDetailsToolCallsObjectType as json.
func (s RunStepDetailsToolCallsObjectType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RunStepDetailsToolCallsObjectType from json.
func (s *RunStepDetailsToolCallsObjectType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunStepDetailsToolCallsObjectType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RunStepDetailsToolCallsObjectType(v) {
	case RunStepDetailsToolCallsObjectTypeToolCalls:
		*s = RunStepDetailsToolCallsObjectTypeToolCalls
	default:
		*s = RunStepDetailsToolCallsObjectType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RunStepDetailsToolCallsObjectType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunStepDetailsToolCallsObjectType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RunStepDetailsToolCallsRetrievalObject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RunStepDetailsToolCallsRetrievalObject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("retrieval")
		s.Retrieval.Encode(e)
	}
}

var jsonFieldsNameOfRunStepDetailsToolCallsRetrievalObject = [2]string{
	0: "id",
	1: "retrieval",
}

// Decode decodes RunStepDetailsToolCallsRetrievalObject from json.
func (s *RunStepDetailsToolCallsRetrievalObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunStepDetailsToolCallsRetrievalObject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "retrieval":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Retrieval.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"retrieval\"")
			}
		case "type":
			return d.Skip()
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RunStepDetailsToolCallsRetrievalObject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRunStepDetailsToolCallsRetrievalObject) {
					name = jsonFieldsNameOfRunStepDetailsToolCallsRetrievalObject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RunStepDetailsToolCallsRetrievalObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunStepDetailsToolCallsRetrievalObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RunStepDetailsToolCallsRetrievalObjectRetrieval) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RunStepDetailsToolCallsRetrievalObjectRetrieval) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfRunStepDetailsToolCallsRetrievalObjectRetrieval = [0]string{}

// Decode decodes RunStepDetailsToolCallsRetrievalObjectRetrieval from json.
func (s *RunStepDetailsToolCallsRetrievalObjectRetrieval) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunStepDetailsToolCallsRetrievalObjectRetrieval to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode RunStepDetailsToolCallsRetrievalObjectRetrieval")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RunStepDetailsToolCallsRetrievalObjectRetrieval) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunStepDetailsToolCallsRetrievalObjectRetrieval) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RunStepObject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RunStepObject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("object")
		s.Object.Encode(e)
	}
	{
		e.FieldStart("created_at")
		e.Int(s.CreatedAt)
	}
	{
		e.FieldStart("assistant_id")
		e.Str(s.AssistantID)
	}
	{
		e.FieldStart("thread_id")
		e.Str(s.ThreadID)
	}
	{
		e.FieldStart("run_id")
		e.Str(s.RunID)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("step_details")
		s.StepDetails.Encode(e)
	}
	{
		e.FieldStart("last_error")
		s.LastError.Encode(e)
	}
	{
		e.FieldStart("expired_at")
		s.ExpiredAt.Encode(e)
	}
	{
		e.FieldStart("cancelled_at")
		s.CancelledAt.Encode(e)
	}
	{
		e.FieldStart("failed_at")
		s.FailedAt.Encode(e)
	}
	{
		e.FieldStart("completed_at")
		s.CompletedAt.Encode(e)
	}
	{
		e.FieldStart("metadata")
		if s.Metadata == nil {
			e.Null()
		} else {
			s.Metadata.Encode(e)
		}
	}
	{
		e.FieldStart("usage")
		s.Usage.Encode(e)
	}
}

var jsonFieldsNameOfRunStepObject = [16]string{
	0:  "id",
	1:  "object",
	2:  "created_at",
	3:  "assistant_id",
	4:  "thread_id",
	5:  "run_id",
	6:  "type",
	7:  "status",
	8:  "step_details",
	9:  "last_error",
	10: "expired_at",
	11: "cancelled_at",
	12: "failed_at",
	13: "completed_at",
	14: "metadata",
	15: "usage",
}

// Decode decodes RunStepObject from json.
func (s *RunStepObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunStepObject to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "object":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CreatedAt = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "assistant_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.AssistantID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assistant_id\"")
			}
		case "thread_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ThreadID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thread_id\"")
			}
		case "run_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.RunID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"run_id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "step_details":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.StepDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"step_details\"")
			}
		case "last_error":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.LastError.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_error\"")
			}
		case "expired_at":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.ExpiredAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expired_at\"")
			}
		case "cancelled_at":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.CancelledAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cancelled_at\"")
			}
		case "failed_at":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.FailedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failed_at\"")
			}
		case "completed_at":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.CompletedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completed_at\"")
			}
		case "metadata":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				s.Metadata = nil
				var elem RunStepObjectMetadata
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Metadata = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "usage":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.Usage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RunStepObject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRunStepObject) {
					name = jsonFieldsNameOfRunStepObject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RunStepObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunStepObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RunStepObjectLastError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RunStepObjectLastError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		s.Code.Encode(e)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfRunStepObjectLastError = [2]string{
	0: "code",
	1: "message",
}

// Decode decodes RunStepObjectLastError from json.
func (s *RunStepObjectLastError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunStepObjectLastError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RunStepObjectLastError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRunStepObjectLastError) {
					name = jsonFieldsNameOfRunStepObjectLastError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RunStepObjectLastError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunStepObjectLastError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RunStepObjectLastErrorCode as json.
func (s RunStepObjectLastErrorCode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RunStepObjectLastErrorCode from json.
func (s *RunStepObjectLastErrorCode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunStepObjectLastErrorCode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RunStepObjectLastErrorCode(v) {
	case RunStepObjectLastErrorCodeServerError:
		*s = RunStepObjectLastErrorCodeServerError
	case RunStepObjectLastErrorCodeRateLimitExceeded:
		*s = RunStepObjectLastErrorCodeRateLimitExceeded
	default:
		*s = RunStepObjectLastErrorCode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RunStepObjectLastErrorCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunStepObjectLastErrorCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RunStepObjectMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RunStepObjectMetadata) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfRunStepObjectMetadata = [0]string{}

// Decode decodes RunStepObjectMetadata from json.
func (s *RunStepObjectMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunStepObjectMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode RunStepObjectMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RunStepObjectMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunStepObjectMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RunStepObjectObject as json.
func (s RunStepObjectObject) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RunStepObjectObject from json.
func (s *RunStepObjectObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunStepObjectObject to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RunStepObjectObject(v) {
	case RunStepObjectObjectThreadRunStep:
		*s = RunStepObjectObjectThreadRunStep
	default:
		*s = RunStepObjectObject(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RunStepObjectObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunStepObjectObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RunStepObjectStatus as json.
func (s RunStepObjectStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RunStepObjectStatus from json.
func (s *RunStepObjectStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunStepObjectStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RunStepObjectStatus(v) {
	case RunStepObjectStatusInProgress:
		*s = RunStepObjectStatusInProgress
	case RunStepObjectStatusCancelled:
		*s = RunStepObjectStatusCancelled
	case RunStepObjectStatusFailed:
		*s = RunStepObjectStatusFailed
	case RunStepObjectStatusCompleted:
		*s = RunStepObjectStatusCompleted
	case RunStepObjectStatusExpired:
		*s = RunStepObjectStatusExpired
	default:
		*s = RunStepObjectStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RunStepObjectStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunStepObjectStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RunStepObjectStepDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RunStepObjectStepDetails) encodeFields(e *jx.Encoder) {
	s.OneOf.encodeFields(e)
}

var jsonFieldsNameOfRunStepObjectStepDetails = [0]string{}

// Decode decodes RunStepObjectStepDetails from json.
func (s *RunStepObjectStepDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunStepObjectStepDetails to nil")
	}
	if err := d.Capture(func(d *jx.Decoder) error {
		return s.OneOf.Decode(d)
	}); err != nil {
		return errors.Wrap(err, "decode field OneOf")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode RunStepObjectStepDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RunStepObjectStepDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunStepObjectStepDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RunStepObjectStepDetailsSum as json.
func (s RunStepObjectStepDetailsSum) Encode(e *jx.Encoder) {
	switch s.Type {
	case RunStepDetailsMessageCreationObjectRunStepObjectStepDetailsSum:
		s.RunStepDetailsMessageCreationObject.Encode(e)
	case RunStepDetailsToolCallsObjectRunStepObjectStepDetailsSum:
		s.RunStepDetailsToolCallsObject.Encode(e)
	}
}

func (s RunStepObjectStepDetailsSum) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case RunStepDetailsMessageCreationObjectRunStepObjectStepDetailsSum:
		s.RunStepDetailsMessageCreationObject.encodeFields(e)
	case RunStepDetailsToolCallsObjectRunStepObjectStepDetailsSum:
		s.RunStepDetailsToolCallsObject.encodeFields(e)
	}
}

// Decode decodes RunStepObjectStepDetailsSum from json.
func (s *RunStepObjectStepDetailsSum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunStepObjectStepDetailsSum to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "message_creation":
				match := RunStepDetailsMessageCreationObjectRunStepObjectStepDetailsSum
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "tool_calls":
				match := RunStepDetailsToolCallsObjectRunStepObjectStepDetailsSum
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case RunStepDetailsMessageCreationObjectRunStepObjectStepDetailsSum:
		if err := s.RunStepDetailsMessageCreationObject.Decode(d); err != nil {
			return err
		}
	case RunStepDetailsToolCallsObjectRunStepObjectStepDetailsSum:
		if err := s.RunStepDetailsToolCallsObject.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RunStepObjectStepDetailsSum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunStepObjectStepDetailsSum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RunStepObjectType as json.
func (s RunStepObjectType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RunStepObjectType from json.
func (s *RunStepObjectType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunStepObjectType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RunStepObjectType(v) {
	case RunStepObjectTypeMessageCreation:
		*s = RunStepObjectTypeMessageCreation
	case RunStepObjectTypeToolCalls:
		*s = RunStepObjectTypeToolCalls
	default:
		*s = RunStepObjectType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RunStepObjectType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunStepObjectType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RunToolCallObject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RunToolCallObject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("function")
		s.Function.Encode(e)
	}
}

var jsonFieldsNameOfRunToolCallObject = [3]string{
	0: "id",
	1: "type",
	2: "function",
}

// Decode decodes RunToolCallObject from json.
func (s *RunToolCallObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunToolCallObject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "function":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Function.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"function\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RunToolCallObject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRunToolCallObject) {
					name = jsonFieldsNameOfRunToolCallObject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RunToolCallObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunToolCallObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RunToolCallObjectFunction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RunToolCallObjectFunction) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("arguments")
		e.Str(s.Arguments)
	}
}

var jsonFieldsNameOfRunToolCallObjectFunction = [2]string{
	0: "name",
	1: "arguments",
}

// Decode decodes RunToolCallObjectFunction from json.
func (s *RunToolCallObjectFunction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunToolCallObjectFunction to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "arguments":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Arguments = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"arguments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RunToolCallObjectFunction")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRunToolCallObjectFunction) {
					name = jsonFieldsNameOfRunToolCallObjectFunction[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RunToolCallObjectFunction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunToolCallObjectFunction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RunToolCallObjectType as json.
func (s RunToolCallObjectType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RunToolCallObjectType from json.
func (s *RunToolCallObjectType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunToolCallObjectType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RunToolCallObjectType(v) {
	case RunToolCallObjectTypeFunction:
		*s = RunToolCallObjectTypeFunction
	default:
		*s = RunToolCallObjectType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RunToolCallObjectType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunToolCallObjectType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubmitToolOutputsRunRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubmitToolOutputsRunRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("tool_outputs")
		e.ArrStart()
		for _, elem := range s.ToolOutputs {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSubmitToolOutputsRunRequest = [1]string{
	0: "tool_outputs",
}

// Decode decodes SubmitToolOutputsRunRequest from json.
func (s *SubmitToolOutputsRunRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubmitToolOutputsRunRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tool_outputs":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.ToolOutputs = make([]SubmitToolOutputsRunRequestToolOutputsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SubmitToolOutputsRunRequestToolOutputsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ToolOutputs = append(s.ToolOutputs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_outputs\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubmitToolOutputsRunRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSubmitToolOutputsRunRequest) {
					name = jsonFieldsNameOfSubmitToolOutputsRunRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubmitToolOutputsRunRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubmitToolOutputsRunRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubmitToolOutputsRunRequestToolOutputsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubmitToolOutputsRunRequestToolOutputsItem) encodeFields(e *jx.Encoder) {
	{
		if s.ToolCallID.Set {
			e.FieldStart("tool_call_id")
			s.ToolCallID.Encode(e)
		}
	}
	{
		if s.Output.Set {
			e.FieldStart("output")
			s.Output.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubmitToolOutputsRunRequestToolOutputsItem = [2]string{
	0: "tool_call_id",
	1: "output",
}

// Decode decodes SubmitToolOutputsRunRequestToolOutputsItem from json.
func (s *SubmitToolOutputsRunRequestToolOutputsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubmitToolOutputsRunRequestToolOutputsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tool_call_id":
			if err := func() error {
				s.ToolCallID.Reset()
				if err := s.ToolCallID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_call_id\"")
			}
		case "output":
			if err := func() error {
				s.Output.Reset()
				if err := s.Output.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"output\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubmitToolOutputsRunRequestToolOutputsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubmitToolOutputsRunRequestToolOutputsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubmitToolOutputsRunRequestToolOutputsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ThreadObject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ThreadObject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("object")
		s.Object.Encode(e)
	}
	{
		e.FieldStart("created_at")
		e.Int(s.CreatedAt)
	}
	{
		e.FieldStart("metadata")
		if s.Metadata == nil {
			e.Null()
		} else {
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfThreadObject = [4]string{
	0: "id",
	1: "object",
	2: "created_at",
	3: "metadata",
}

// Decode decodes ThreadObject from json.
func (s *ThreadObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ThreadObject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "object":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CreatedAt = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "metadata":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Metadata = nil
				var elem ThreadObjectMetadata
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Metadata = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ThreadObject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfThreadObject) {
					name = jsonFieldsNameOfThreadObject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ThreadObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ThreadObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ThreadObjectMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ThreadObjectMetadata) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfThreadObjectMetadata = [0]string{}

// Decode decodes ThreadObjectMetadata from json.
func (s *ThreadObjectMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ThreadObjectMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ThreadObjectMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ThreadObjectMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ThreadObjectMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ThreadObjectObject as json.
func (s ThreadObjectObject) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ThreadObjectObject from json.
func (s *ThreadObjectObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ThreadObjectObject to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ThreadObjectObject(v) {
	case ThreadObjectObjectThread:
		*s = ThreadObjectObjectThread
	default:
		*s = ThreadObjectObject(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ThreadObjectObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ThreadObjectObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TranscriptionSegment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TranscriptionSegment) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("seek")
		e.Int(s.Seek)
	}
	{
		e.FieldStart("start")
		e.Float32(s.Start)
	}
	{
		e.FieldStart("end")
		e.Float32(s.End)
	}
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		e.FieldStart("tokens")
		e.ArrStart()
		for _, elem := range s.Tokens {
			e.Int(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("temperature")
		e.Float32(s.Temperature)
	}
	{
		e.FieldStart("avg_logprob")
		e.Float32(s.AvgLogprob)
	}
	{
		e.FieldStart("compression_ratio")
		e.Float32(s.CompressionRatio)
	}
	{
		e.FieldStart("no_speech_prob")
		e.Float32(s.NoSpeechProb)
	}
}

var jsonFieldsNameOfTranscriptionSegment = [10]string{
	0: "id",
	1: "seek",
	2: "start",
	3: "end",
	4: "text",
	5: "tokens",
	6: "temperature",
	7: "avg_logprob",
	8: "compression_ratio",
	9: "no_speech_prob",
}

// Decode decodes TranscriptionSegment from json.
func (s *TranscriptionSegment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TranscriptionSegment to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "seek":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Seek = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seek\"")
			}
		case "start":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float32()
				s.Start = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "end":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float32()
				s.End = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		case "text":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "tokens":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.Tokens = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Tokens = append(s.Tokens, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tokens\"")
			}
		case "temperature":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Float32()
				s.Temperature = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temperature\"")
			}
		case "avg_logprob":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Float32()
				s.AvgLogprob = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avg_logprob\"")
			}
		case "compression_ratio":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Float32()
				s.CompressionRatio = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compression_ratio\"")
			}
		case "no_speech_prob":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.NoSpeechProb = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"no_speech_prob\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TranscriptionSegment")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTranscriptionSegment) {
					name = jsonFieldsNameOfTranscriptionSegment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TranscriptionSegment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TranscriptionSegment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TranscriptionWord) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TranscriptionWord) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("word")
		e.Str(s.Word)
	}
	{
		e.FieldStart("start")
		e.Float32(s.Start)
	}
	{
		e.FieldStart("end")
		e.Float32(s.End)
	}
}

var jsonFieldsNameOfTranscriptionWord = [3]string{
	0: "word",
	1: "start",
	2: "end",
}

// Decode decodes TranscriptionWord from json.
func (s *TranscriptionWord) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TranscriptionWord to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "word":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Word = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"word\"")
			}
		case "start":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.Start = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "end":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float32()
				s.End = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TranscriptionWord")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTranscriptionWord) {
					name = jsonFieldsNameOfTranscriptionWord[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TranscriptionWord) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TranscriptionWord) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
