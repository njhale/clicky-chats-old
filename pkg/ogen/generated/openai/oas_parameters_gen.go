// Code generated by ogen, DO NOT EDIT.

package api

import (
	"net/http"
	"net/url"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

// CancelFineTuningJobParams is parameters of cancelFineTuningJob operation.
type CancelFineTuningJobParams struct {
	// The ID of the fine-tuning job to cancel.
	FineTuningJobID string
}

func unpackCancelFineTuningJobParams(packed middleware.Parameters) (params CancelFineTuningJobParams) {
	{
		key := middleware.ParameterKey{
			Name: "fine_tuning_job_id",
			In:   "path",
		}
		params.FineTuningJobID = packed[key].(string)
	}
	return params
}

func decodeCancelFineTuningJobParams(args [1]string, argsEscaped bool, r *http.Request) (params CancelFineTuningJobParams, _ error) {
	// Decode path: fine_tuning_job_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "fine_tuning_job_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.FineTuningJobID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "fine_tuning_job_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// CancelRunParams is parameters of cancelRun operation.
type CancelRunParams struct {
	// The ID of the thread to which this run belongs.
	ThreadID string
	// The ID of the run to cancel.
	RunID string
}

func unpackCancelRunParams(packed middleware.Parameters) (params CancelRunParams) {
	{
		key := middleware.ParameterKey{
			Name: "thread_id",
			In:   "path",
		}
		params.ThreadID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "run_id",
			In:   "path",
		}
		params.RunID = packed[key].(string)
	}
	return params
}

func decodeCancelRunParams(args [2]string, argsEscaped bool, r *http.Request) (params CancelRunParams, _ error) {
	// Decode path: thread_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "thread_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: run_id.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "run_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// CreateAssistantFileParams is parameters of createAssistantFile operation.
type CreateAssistantFileParams struct {
	// The ID of the assistant for which to create a File.
	AssistantID string
}

func unpackCreateAssistantFileParams(packed middleware.Parameters) (params CreateAssistantFileParams) {
	{
		key := middleware.ParameterKey{
			Name: "assistant_id",
			In:   "path",
		}
		params.AssistantID = packed[key].(string)
	}
	return params
}

func decodeCreateAssistantFileParams(args [1]string, argsEscaped bool, r *http.Request) (params CreateAssistantFileParams, _ error) {
	// Decode path: assistant_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "assistant_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AssistantID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "assistant_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// CreateMessageParams is parameters of createMessage operation.
type CreateMessageParams struct {
	// The ID of the [thread](/docs/api-reference/threads) to create a message for.
	ThreadID string
}

func unpackCreateMessageParams(packed middleware.Parameters) (params CreateMessageParams) {
	{
		key := middleware.ParameterKey{
			Name: "thread_id",
			In:   "path",
		}
		params.ThreadID = packed[key].(string)
	}
	return params
}

func decodeCreateMessageParams(args [1]string, argsEscaped bool, r *http.Request) (params CreateMessageParams, _ error) {
	// Decode path: thread_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "thread_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// CreateRunParams is parameters of createRun operation.
type CreateRunParams struct {
	// The ID of the thread to run.
	ThreadID string
}

func unpackCreateRunParams(packed middleware.Parameters) (params CreateRunParams) {
	{
		key := middleware.ParameterKey{
			Name: "thread_id",
			In:   "path",
		}
		params.ThreadID = packed[key].(string)
	}
	return params
}

func decodeCreateRunParams(args [1]string, argsEscaped bool, r *http.Request) (params CreateRunParams, _ error) {
	// Decode path: thread_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "thread_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteAssistantParams is parameters of deleteAssistant operation.
type DeleteAssistantParams struct {
	// The ID of the assistant to delete.
	AssistantID string
}

func unpackDeleteAssistantParams(packed middleware.Parameters) (params DeleteAssistantParams) {
	{
		key := middleware.ParameterKey{
			Name: "assistant_id",
			In:   "path",
		}
		params.AssistantID = packed[key].(string)
	}
	return params
}

func decodeDeleteAssistantParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteAssistantParams, _ error) {
	// Decode path: assistant_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "assistant_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AssistantID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "assistant_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteAssistantFileParams is parameters of deleteAssistantFile operation.
type DeleteAssistantFileParams struct {
	// The ID of the assistant that the file belongs to.
	AssistantID string
	// The ID of the file to delete.
	FileID string
}

func unpackDeleteAssistantFileParams(packed middleware.Parameters) (params DeleteAssistantFileParams) {
	{
		key := middleware.ParameterKey{
			Name: "assistant_id",
			In:   "path",
		}
		params.AssistantID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "file_id",
			In:   "path",
		}
		params.FileID = packed[key].(string)
	}
	return params
}

func decodeDeleteAssistantFileParams(args [2]string, argsEscaped bool, r *http.Request) (params DeleteAssistantFileParams, _ error) {
	// Decode path: assistant_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "assistant_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AssistantID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "assistant_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: file_id.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "file_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.FileID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "file_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteFileParams is parameters of deleteFile operation.
type DeleteFileParams struct {
	// The ID of the file to use for this request.
	FileID string
}

func unpackDeleteFileParams(packed middleware.Parameters) (params DeleteFileParams) {
	{
		key := middleware.ParameterKey{
			Name: "file_id",
			In:   "path",
		}
		params.FileID = packed[key].(string)
	}
	return params
}

func decodeDeleteFileParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteFileParams, _ error) {
	// Decode path: file_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "file_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.FileID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "file_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteModelParams is parameters of deleteModel operation.
type DeleteModelParams struct {
	// The model to delete.
	Model string
}

func unpackDeleteModelParams(packed middleware.Parameters) (params DeleteModelParams) {
	{
		key := middleware.ParameterKey{
			Name: "model",
			In:   "path",
		}
		params.Model = packed[key].(string)
	}
	return params
}

func decodeDeleteModelParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteModelParams, _ error) {
	// Decode path: model.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "model",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Model = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "model",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteThreadParams is parameters of deleteThread operation.
type DeleteThreadParams struct {
	// The ID of the thread to delete.
	ThreadID string
}

func unpackDeleteThreadParams(packed middleware.Parameters) (params DeleteThreadParams) {
	{
		key := middleware.ParameterKey{
			Name: "thread_id",
			In:   "path",
		}
		params.ThreadID = packed[key].(string)
	}
	return params
}

func decodeDeleteThreadParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteThreadParams, _ error) {
	// Decode path: thread_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "thread_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DownloadFileParams is parameters of downloadFile operation.
type DownloadFileParams struct {
	// The ID of the file to use for this request.
	FileID string
}

func unpackDownloadFileParams(packed middleware.Parameters) (params DownloadFileParams) {
	{
		key := middleware.ParameterKey{
			Name: "file_id",
			In:   "path",
		}
		params.FileID = packed[key].(string)
	}
	return params
}

func decodeDownloadFileParams(args [1]string, argsEscaped bool, r *http.Request) (params DownloadFileParams, _ error) {
	// Decode path: file_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "file_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.FileID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "file_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetAssistantParams is parameters of getAssistant operation.
type GetAssistantParams struct {
	// The ID of the assistant to retrieve.
	AssistantID string
}

func unpackGetAssistantParams(packed middleware.Parameters) (params GetAssistantParams) {
	{
		key := middleware.ParameterKey{
			Name: "assistant_id",
			In:   "path",
		}
		params.AssistantID = packed[key].(string)
	}
	return params
}

func decodeGetAssistantParams(args [1]string, argsEscaped bool, r *http.Request) (params GetAssistantParams, _ error) {
	// Decode path: assistant_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "assistant_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AssistantID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "assistant_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetAssistantFileParams is parameters of getAssistantFile operation.
type GetAssistantFileParams struct {
	// The ID of the assistant who the file belongs to.
	AssistantID string
	// The ID of the file we're getting.
	FileID string
}

func unpackGetAssistantFileParams(packed middleware.Parameters) (params GetAssistantFileParams) {
	{
		key := middleware.ParameterKey{
			Name: "assistant_id",
			In:   "path",
		}
		params.AssistantID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "file_id",
			In:   "path",
		}
		params.FileID = packed[key].(string)
	}
	return params
}

func decodeGetAssistantFileParams(args [2]string, argsEscaped bool, r *http.Request) (params GetAssistantFileParams, _ error) {
	// Decode path: assistant_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "assistant_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AssistantID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "assistant_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: file_id.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "file_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.FileID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "file_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetMessageParams is parameters of getMessage operation.
type GetMessageParams struct {
	// The ID of the [thread](/docs/api-reference/threads) to which this message belongs.
	ThreadID string
	// The ID of the message to retrieve.
	MessageID string
}

func unpackGetMessageParams(packed middleware.Parameters) (params GetMessageParams) {
	{
		key := middleware.ParameterKey{
			Name: "thread_id",
			In:   "path",
		}
		params.ThreadID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "message_id",
			In:   "path",
		}
		params.MessageID = packed[key].(string)
	}
	return params
}

func decodeGetMessageParams(args [2]string, argsEscaped bool, r *http.Request) (params GetMessageParams, _ error) {
	// Decode path: thread_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "thread_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: message_id.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "message_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.MessageID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "message_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetMessageFileParams is parameters of getMessageFile operation.
type GetMessageFileParams struct {
	// The ID of the thread to which the message and File belong.
	ThreadID string
	// The ID of the message the file belongs to.
	MessageID string
	// The ID of the file being retrieved.
	FileID string
}

func unpackGetMessageFileParams(packed middleware.Parameters) (params GetMessageFileParams) {
	{
		key := middleware.ParameterKey{
			Name: "thread_id",
			In:   "path",
		}
		params.ThreadID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "message_id",
			In:   "path",
		}
		params.MessageID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "file_id",
			In:   "path",
		}
		params.FileID = packed[key].(string)
	}
	return params
}

func decodeGetMessageFileParams(args [3]string, argsEscaped bool, r *http.Request) (params GetMessageFileParams, _ error) {
	// Decode path: thread_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "thread_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: message_id.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "message_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.MessageID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "message_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: file_id.
	if err := func() error {
		param := args[2]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[2])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "file_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.FileID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "file_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetRunParams is parameters of getRun operation.
type GetRunParams struct {
	// The ID of the [thread](/docs/api-reference/threads) that was run.
	ThreadID string
	// The ID of the run to retrieve.
	RunID string
}

func unpackGetRunParams(packed middleware.Parameters) (params GetRunParams) {
	{
		key := middleware.ParameterKey{
			Name: "thread_id",
			In:   "path",
		}
		params.ThreadID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "run_id",
			In:   "path",
		}
		params.RunID = packed[key].(string)
	}
	return params
}

func decodeGetRunParams(args [2]string, argsEscaped bool, r *http.Request) (params GetRunParams, _ error) {
	// Decode path: thread_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "thread_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: run_id.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "run_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetRunStepParams is parameters of getRunStep operation.
type GetRunStepParams struct {
	// The ID of the thread to which the run and run step belongs.
	ThreadID string
	// The ID of the run to which the run step belongs.
	RunID string
	// The ID of the run step to retrieve.
	StepID string
}

func unpackGetRunStepParams(packed middleware.Parameters) (params GetRunStepParams) {
	{
		key := middleware.ParameterKey{
			Name: "thread_id",
			In:   "path",
		}
		params.ThreadID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "run_id",
			In:   "path",
		}
		params.RunID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "step_id",
			In:   "path",
		}
		params.StepID = packed[key].(string)
	}
	return params
}

func decodeGetRunStepParams(args [3]string, argsEscaped bool, r *http.Request) (params GetRunStepParams, _ error) {
	// Decode path: thread_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "thread_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: run_id.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "run_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: step_id.
	if err := func() error {
		param := args[2]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[2])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "step_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.StepID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "step_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetThreadParams is parameters of getThread operation.
type GetThreadParams struct {
	// The ID of the thread to retrieve.
	ThreadID string
}

func unpackGetThreadParams(packed middleware.Parameters) (params GetThreadParams) {
	{
		key := middleware.ParameterKey{
			Name: "thread_id",
			In:   "path",
		}
		params.ThreadID = packed[key].(string)
	}
	return params
}

func decodeGetThreadParams(args [1]string, argsEscaped bool, r *http.Request) (params GetThreadParams, _ error) {
	// Decode path: thread_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "thread_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ListAssistantFilesParams is parameters of listAssistantFiles operation.
type ListAssistantFilesParams struct {
	// The ID of the assistant the file belongs to.
	AssistantID string
	// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
	// default is 20.
	Limit OptInt
	// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for
	// descending order.
	Order OptListAssistantFilesOrder
	// A cursor for use in pagination. `after` is an object ID that defines your place in the list. For
	// instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent
	// call can include after=obj_foo in order to fetch the next page of the list.
	After OptString
	// A cursor for use in pagination. `before` is an object ID that defines your place in the list. For
	// instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent
	// call can include before=obj_foo in order to fetch the previous page of the list.
	Before OptString
}

func unpackListAssistantFilesParams(packed middleware.Parameters) (params ListAssistantFilesParams) {
	{
		key := middleware.ParameterKey{
			Name: "assistant_id",
			In:   "path",
		}
		params.AssistantID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "order",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Order = v.(OptListAssistantFilesOrder)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "after",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.After = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "before",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Before = v.(OptString)
		}
	}
	return params
}

func decodeListAssistantFilesParams(args [1]string, argsEscaped bool, r *http.Request) (params ListAssistantFilesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: assistant_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "assistant_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AssistantID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "assistant_id",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(20)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: order.
	{
		val := ListAssistantFilesOrder("desc")
		params.Order.SetTo(val)
	}
	// Decode query: order.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrderVal ListAssistantFilesOrder
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotOrderVal = ListAssistantFilesOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Order.SetTo(paramsDotOrderVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Order.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "order",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: after.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "after",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAfterVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAfterVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.After.SetTo(paramsDotAfterVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "after",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: before.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "before",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBeforeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotBeforeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Before.SetTo(paramsDotBeforeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "before",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListAssistantsParams is parameters of listAssistants operation.
type ListAssistantsParams struct {
	// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
	// default is 20.
	Limit OptInt
	// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for
	// descending order.
	Order OptListAssistantsOrder
	// A cursor for use in pagination. `after` is an object ID that defines your place in the list. For
	// instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent
	// call can include after=obj_foo in order to fetch the next page of the list.
	After OptString
	// A cursor for use in pagination. `before` is an object ID that defines your place in the list. For
	// instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent
	// call can include before=obj_foo in order to fetch the previous page of the list.
	Before OptString
}

func unpackListAssistantsParams(packed middleware.Parameters) (params ListAssistantsParams) {
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "order",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Order = v.(OptListAssistantsOrder)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "after",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.After = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "before",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Before = v.(OptString)
		}
	}
	return params
}

func decodeListAssistantsParams(args [0]string, argsEscaped bool, r *http.Request) (params ListAssistantsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: limit.
	{
		val := int(20)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: order.
	{
		val := ListAssistantsOrder("desc")
		params.Order.SetTo(val)
	}
	// Decode query: order.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrderVal ListAssistantsOrder
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotOrderVal = ListAssistantsOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Order.SetTo(paramsDotOrderVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Order.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "order",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: after.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "after",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAfterVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAfterVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.After.SetTo(paramsDotAfterVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "after",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: before.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "before",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBeforeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotBeforeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Before.SetTo(paramsDotBeforeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "before",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListFilesParams is parameters of listFiles operation.
type ListFilesParams struct {
	// Only return files with the given purpose.
	Purpose OptString
}

func unpackListFilesParams(packed middleware.Parameters) (params ListFilesParams) {
	{
		key := middleware.ParameterKey{
			Name: "purpose",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Purpose = v.(OptString)
		}
	}
	return params
}

func decodeListFilesParams(args [0]string, argsEscaped bool, r *http.Request) (params ListFilesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: purpose.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "purpose",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPurposeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPurposeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Purpose.SetTo(paramsDotPurposeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "purpose",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListFineTuningEventsParams is parameters of listFineTuningEvents operation.
type ListFineTuningEventsParams struct {
	// The ID of the fine-tuning job to get events for.
	FineTuningJobID string
	// Identifier for the last event from the previous pagination request.
	After OptString
	// Number of events to retrieve.
	Limit OptInt
}

func unpackListFineTuningEventsParams(packed middleware.Parameters) (params ListFineTuningEventsParams) {
	{
		key := middleware.ParameterKey{
			Name: "fine_tuning_job_id",
			In:   "path",
		}
		params.FineTuningJobID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "after",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.After = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	return params
}

func decodeListFineTuningEventsParams(args [1]string, argsEscaped bool, r *http.Request) (params ListFineTuningEventsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: fine_tuning_job_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "fine_tuning_job_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.FineTuningJobID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "fine_tuning_job_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: after.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "after",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAfterVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAfterVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.After.SetTo(paramsDotAfterVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "after",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(20)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListMessageFilesParams is parameters of listMessageFiles operation.
type ListMessageFilesParams struct {
	// The ID of the thread that the message and files belong to.
	ThreadID string
	// The ID of the message that the files belongs to.
	MessageID string
	// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
	// default is 20.
	Limit OptInt
	// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for
	// descending order.
	Order OptListMessageFilesOrder
	// A cursor for use in pagination. `after` is an object ID that defines your place in the list. For
	// instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent
	// call can include after=obj_foo in order to fetch the next page of the list.
	After OptString
	// A cursor for use in pagination. `before` is an object ID that defines your place in the list. For
	// instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent
	// call can include before=obj_foo in order to fetch the previous page of the list.
	Before OptString
}

func unpackListMessageFilesParams(packed middleware.Parameters) (params ListMessageFilesParams) {
	{
		key := middleware.ParameterKey{
			Name: "thread_id",
			In:   "path",
		}
		params.ThreadID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "message_id",
			In:   "path",
		}
		params.MessageID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "order",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Order = v.(OptListMessageFilesOrder)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "after",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.After = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "before",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Before = v.(OptString)
		}
	}
	return params
}

func decodeListMessageFilesParams(args [2]string, argsEscaped bool, r *http.Request) (params ListMessageFilesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: thread_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "thread_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: message_id.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "message_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.MessageID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "message_id",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(20)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: order.
	{
		val := ListMessageFilesOrder("desc")
		params.Order.SetTo(val)
	}
	// Decode query: order.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrderVal ListMessageFilesOrder
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotOrderVal = ListMessageFilesOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Order.SetTo(paramsDotOrderVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Order.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "order",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: after.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "after",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAfterVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAfterVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.After.SetTo(paramsDotAfterVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "after",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: before.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "before",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBeforeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotBeforeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Before.SetTo(paramsDotBeforeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "before",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListMessagesParams is parameters of listMessages operation.
type ListMessagesParams struct {
	// The ID of the [thread](/docs/api-reference/threads) the messages belong to.
	ThreadID string
	// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
	// default is 20.
	Limit OptInt
	// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for
	// descending order.
	Order OptListMessagesOrder
	// A cursor for use in pagination. `after` is an object ID that defines your place in the list. For
	// instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent
	// call can include after=obj_foo in order to fetch the next page of the list.
	After OptString
	// A cursor for use in pagination. `before` is an object ID that defines your place in the list. For
	// instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent
	// call can include before=obj_foo in order to fetch the previous page of the list.
	Before OptString
}

func unpackListMessagesParams(packed middleware.Parameters) (params ListMessagesParams) {
	{
		key := middleware.ParameterKey{
			Name: "thread_id",
			In:   "path",
		}
		params.ThreadID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "order",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Order = v.(OptListMessagesOrder)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "after",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.After = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "before",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Before = v.(OptString)
		}
	}
	return params
}

func decodeListMessagesParams(args [1]string, argsEscaped bool, r *http.Request) (params ListMessagesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: thread_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "thread_id",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(20)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: order.
	{
		val := ListMessagesOrder("desc")
		params.Order.SetTo(val)
	}
	// Decode query: order.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrderVal ListMessagesOrder
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotOrderVal = ListMessagesOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Order.SetTo(paramsDotOrderVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Order.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "order",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: after.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "after",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAfterVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAfterVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.After.SetTo(paramsDotAfterVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "after",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: before.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "before",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBeforeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotBeforeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Before.SetTo(paramsDotBeforeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "before",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListPaginatedFineTuningJobsParams is parameters of listPaginatedFineTuningJobs operation.
type ListPaginatedFineTuningJobsParams struct {
	// Identifier for the last job from the previous pagination request.
	After OptString
	// Number of fine-tuning jobs to retrieve.
	Limit OptInt
}

func unpackListPaginatedFineTuningJobsParams(packed middleware.Parameters) (params ListPaginatedFineTuningJobsParams) {
	{
		key := middleware.ParameterKey{
			Name: "after",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.After = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	return params
}

func decodeListPaginatedFineTuningJobsParams(args [0]string, argsEscaped bool, r *http.Request) (params ListPaginatedFineTuningJobsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: after.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "after",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAfterVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAfterVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.After.SetTo(paramsDotAfterVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "after",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(20)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListRunStepsParams is parameters of listRunSteps operation.
type ListRunStepsParams struct {
	// The ID of the thread the run and run steps belong to.
	ThreadID string
	// The ID of the run the run steps belong to.
	RunID string
	// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
	// default is 20.
	Limit OptInt
	// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for
	// descending order.
	Order OptListRunStepsOrder
	// A cursor for use in pagination. `after` is an object ID that defines your place in the list. For
	// instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent
	// call can include after=obj_foo in order to fetch the next page of the list.
	After OptString
	// A cursor for use in pagination. `before` is an object ID that defines your place in the list. For
	// instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent
	// call can include before=obj_foo in order to fetch the previous page of the list.
	Before OptString
}

func unpackListRunStepsParams(packed middleware.Parameters) (params ListRunStepsParams) {
	{
		key := middleware.ParameterKey{
			Name: "thread_id",
			In:   "path",
		}
		params.ThreadID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "run_id",
			In:   "path",
		}
		params.RunID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "order",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Order = v.(OptListRunStepsOrder)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "after",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.After = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "before",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Before = v.(OptString)
		}
	}
	return params
}

func decodeListRunStepsParams(args [2]string, argsEscaped bool, r *http.Request) (params ListRunStepsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: thread_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "thread_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: run_id.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "run_id",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(20)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: order.
	{
		val := ListRunStepsOrder("desc")
		params.Order.SetTo(val)
	}
	// Decode query: order.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrderVal ListRunStepsOrder
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotOrderVal = ListRunStepsOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Order.SetTo(paramsDotOrderVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Order.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "order",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: after.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "after",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAfterVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAfterVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.After.SetTo(paramsDotAfterVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "after",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: before.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "before",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBeforeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotBeforeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Before.SetTo(paramsDotBeforeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "before",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListRunsParams is parameters of listRuns operation.
type ListRunsParams struct {
	// The ID of the thread the run belongs to.
	ThreadID string
	// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
	// default is 20.
	Limit OptInt
	// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for
	// descending order.
	Order OptListRunsOrder
	// A cursor for use in pagination. `after` is an object ID that defines your place in the list. For
	// instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent
	// call can include after=obj_foo in order to fetch the next page of the list.
	After OptString
	// A cursor for use in pagination. `before` is an object ID that defines your place in the list. For
	// instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent
	// call can include before=obj_foo in order to fetch the previous page of the list.
	Before OptString
}

func unpackListRunsParams(packed middleware.Parameters) (params ListRunsParams) {
	{
		key := middleware.ParameterKey{
			Name: "thread_id",
			In:   "path",
		}
		params.ThreadID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "order",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Order = v.(OptListRunsOrder)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "after",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.After = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "before",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Before = v.(OptString)
		}
	}
	return params
}

func decodeListRunsParams(args [1]string, argsEscaped bool, r *http.Request) (params ListRunsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: thread_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "thread_id",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := int(20)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: order.
	{
		val := ListRunsOrder("desc")
		params.Order.SetTo(val)
	}
	// Decode query: order.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrderVal ListRunsOrder
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotOrderVal = ListRunsOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Order.SetTo(paramsDotOrderVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Order.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "order",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: after.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "after",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAfterVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAfterVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.After.SetTo(paramsDotAfterVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "after",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: before.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "before",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBeforeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotBeforeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Before.SetTo(paramsDotBeforeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "before",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ModifyAssistantParams is parameters of modifyAssistant operation.
type ModifyAssistantParams struct {
	// The ID of the assistant to modify.
	AssistantID string
}

func unpackModifyAssistantParams(packed middleware.Parameters) (params ModifyAssistantParams) {
	{
		key := middleware.ParameterKey{
			Name: "assistant_id",
			In:   "path",
		}
		params.AssistantID = packed[key].(string)
	}
	return params
}

func decodeModifyAssistantParams(args [1]string, argsEscaped bool, r *http.Request) (params ModifyAssistantParams, _ error) {
	// Decode path: assistant_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "assistant_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AssistantID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "assistant_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ModifyMessageParams is parameters of modifyMessage operation.
type ModifyMessageParams struct {
	// The ID of the thread to which this message belongs.
	ThreadID string
	// The ID of the message to modify.
	MessageID string
}

func unpackModifyMessageParams(packed middleware.Parameters) (params ModifyMessageParams) {
	{
		key := middleware.ParameterKey{
			Name: "thread_id",
			In:   "path",
		}
		params.ThreadID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "message_id",
			In:   "path",
		}
		params.MessageID = packed[key].(string)
	}
	return params
}

func decodeModifyMessageParams(args [2]string, argsEscaped bool, r *http.Request) (params ModifyMessageParams, _ error) {
	// Decode path: thread_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "thread_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: message_id.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "message_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.MessageID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "message_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ModifyRunParams is parameters of modifyRun operation.
type ModifyRunParams struct {
	// The ID of the [thread](/docs/api-reference/threads) that was run.
	ThreadID string
	// The ID of the run to modify.
	RunID string
}

func unpackModifyRunParams(packed middleware.Parameters) (params ModifyRunParams) {
	{
		key := middleware.ParameterKey{
			Name: "thread_id",
			In:   "path",
		}
		params.ThreadID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "run_id",
			In:   "path",
		}
		params.RunID = packed[key].(string)
	}
	return params
}

func decodeModifyRunParams(args [2]string, argsEscaped bool, r *http.Request) (params ModifyRunParams, _ error) {
	// Decode path: thread_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "thread_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: run_id.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "run_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ModifyThreadParams is parameters of modifyThread operation.
type ModifyThreadParams struct {
	// The ID of the thread to modify. Only the `metadata` can be modified.
	ThreadID string
}

func unpackModifyThreadParams(packed middleware.Parameters) (params ModifyThreadParams) {
	{
		key := middleware.ParameterKey{
			Name: "thread_id",
			In:   "path",
		}
		params.ThreadID = packed[key].(string)
	}
	return params
}

func decodeModifyThreadParams(args [1]string, argsEscaped bool, r *http.Request) (params ModifyThreadParams, _ error) {
	// Decode path: thread_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "thread_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// RetrieveFileParams is parameters of retrieveFile operation.
type RetrieveFileParams struct {
	// The ID of the file to use for this request.
	FileID string
}

func unpackRetrieveFileParams(packed middleware.Parameters) (params RetrieveFileParams) {
	{
		key := middleware.ParameterKey{
			Name: "file_id",
			In:   "path",
		}
		params.FileID = packed[key].(string)
	}
	return params
}

func decodeRetrieveFileParams(args [1]string, argsEscaped bool, r *http.Request) (params RetrieveFileParams, _ error) {
	// Decode path: file_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "file_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.FileID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "file_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// RetrieveFineTuningJobParams is parameters of retrieveFineTuningJob operation.
type RetrieveFineTuningJobParams struct {
	// The ID of the fine-tuning job.
	FineTuningJobID string
}

func unpackRetrieveFineTuningJobParams(packed middleware.Parameters) (params RetrieveFineTuningJobParams) {
	{
		key := middleware.ParameterKey{
			Name: "fine_tuning_job_id",
			In:   "path",
		}
		params.FineTuningJobID = packed[key].(string)
	}
	return params
}

func decodeRetrieveFineTuningJobParams(args [1]string, argsEscaped bool, r *http.Request) (params RetrieveFineTuningJobParams, _ error) {
	// Decode path: fine_tuning_job_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "fine_tuning_job_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.FineTuningJobID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "fine_tuning_job_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// RetrieveModelParams is parameters of retrieveModel operation.
type RetrieveModelParams struct {
	// The ID of the model to use for this request.
	Model string
}

func unpackRetrieveModelParams(packed middleware.Parameters) (params RetrieveModelParams) {
	{
		key := middleware.ParameterKey{
			Name: "model",
			In:   "path",
		}
		params.Model = packed[key].(string)
	}
	return params
}

func decodeRetrieveModelParams(args [1]string, argsEscaped bool, r *http.Request) (params RetrieveModelParams, _ error) {
	// Decode path: model.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "model",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Model = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "model",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// SubmitToolOuputsToRunParams is parameters of submitToolOuputsToRun operation.
type SubmitToolOuputsToRunParams struct {
	// The ID of the [thread](/docs/api-reference/threads) to which this run belongs.
	ThreadID string
	// The ID of the run that requires the tool output submission.
	RunID string
}

func unpackSubmitToolOuputsToRunParams(packed middleware.Parameters) (params SubmitToolOuputsToRunParams) {
	{
		key := middleware.ParameterKey{
			Name: "thread_id",
			In:   "path",
		}
		params.ThreadID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "run_id",
			In:   "path",
		}
		params.RunID = packed[key].(string)
	}
	return params
}

func decodeSubmitToolOuputsToRunParams(args [2]string, argsEscaped bool, r *http.Request) (params SubmitToolOuputsToRunParams, _ error) {
	// Decode path: thread_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "thread_id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: run_id.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "run_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}
